{
  "docs/protocol/governance": "# Governance\n\n## Role\n\nThe NDX governance organization is responsible for:\n- Upgrading proxy implementations as needed.\n- Deploying new index pools.\n- Managing the token categories which indices select from and creating new ones.\n- Approving pool controllers that implement new management strategies.\n- Setting configuration values such as swap fees.\n\n## NDX Token Distribution\n\nNDX is the governance token for Indexed. The initial supply of 10,000,000 NDX will be distributed as follows:\n- 30% will be made available to the NDX treasury over the course of 9 months, beginning March 1, 2021.\n- 25% will be distributed through liquidity mining to users who stake CC10/DEFI5 index tokens or their Uniswap Ether pair LP tokens (ending March 8th 2021).\n- 20% will go to the founders, investors and future team members, subject to vesting periods.\n- 14% will be distributed via the treasury in a manner to be determined by governance.\n- 6% will be distributed through liquidity mining to users who stake index tokens or Uniswap Ether pair LP tokens as part of the [Sigma program](https://forum.indexed.finance/t/iip-4-sigma-pilot/74).\n- 5% will be used to reward keepers who update the Uniswap oracle and trigger periodic updates on the pool controller.\n\nAfter June 1, 2021 the ability to mint new NDX tokens will be available to the governance organization.\n\nMinting is restricted to a maximum of 10% of the supply (at the time tokens are minted) and may only occur once every 90 days. NDX governance may also disable minting permanently by changing the minter address from the timelock contract to the null address.\n\n## Early Governance\n\nIn order to ensure the security of the project while distribution is underway, the team will retain the ability to create and vote on governance proposals while our tokens are vesting. This will ensure that we are able to respond if security incidents occur prior to the completion of the initial distribution, but all successful proposals will still be subject to the two day time lock. Additionally, the voting period on the governor contract is temporarily set to a value which corresponds to about 12 hours in blocks; after January 7, 2021, anyone can call a function on the governor to set the voting period to its permanent value, which is closer to 3 days.\n\n## Keepers\n\nThe 5% allocation for keepers is currently held by the timelock contract and will be transferred once we complete development and testing of the keeper bot and contract. Until then we will trigger the updates ourselves, and anyone else can do so on Etherscan.",
  "docs/protocol/index-controller": "# Index Pool Controller\n\nThe index pool controller is a contract which tracks token values and sets portfolio targets using an adjusted capitalization-weighted formula. The NDX governance dao has the ability to create and manage token categories on the controller, which are baskets of assets with some arbitrary commonality. \n\n## Category Token Selection\n\nThe current rules for inclusion in each category can be found on their respective pages on the app.\n\n- [Decentralized Finance Category](https://indexed.finance/category/0x2)\n- [Cryptocurrency Category](https://indexed.finance/category/0x1)\n\n## Category Sorting\nToken categories are regularly sorted in descending order of the tokens' market caps using a weekly moving average of the tokens' prices. Market caps are extrapolated by taking the weekly moving average price of a token returned by the Uniswap oracle and multiplying by its total supply. In the future we plan on using more advanced metrics like float-adjusted capitalization, as is used in S&P indices, to get a more accurate representation of the value of tokens' active liquidity.\n\n## Index Token Selection\nWhen an index is first deployed, and each month thereafter, the controller selects the top $$n$$ tokens in its category as the target portfolio assets, where $$n$$ is the index size set at deployment. The tokens must be sorted within the 24 hour period prior to the selection process. Further details can be found in the documentation regarding pool re-indexing.\n\n## Token Weighting Algorithm\nBecause tokens in the DeFi ecosystem have such a wide range of market caps, we decided to use an adjusted algorithm for computing token weights. Rather than weighing assets by market cap, we weigh them by market cap square root. This algorithm still favors tokens with larger market caps but does not result in some assets having such a massively higher weight than the others that the smaller cap tokens are effectively irrelevant, which would be the case in many indices if standard market cap weighting was used.\n\nThe algorithm to compute the weight of token $$t$$ in an index with $$l$$ tokens, where $$m(T_{n})$$ is the extrapolated market cap of the $$n^{th}$$ token, is:\n$$\nw(t) = \\frac{\\sqrt{m(t)}}{\\sum_{n=0}^{n < l} {\\sqrt{m(T_{n})}}}\n$$",
  "docs/protocol/pools": "# Summary\n\nIndex pools are tokenized portfolios that double as AMMs. The pool contract is designed to be able to radically change the composition of its portfolio without needing to access external liquidity.\n\nThe Index Pool contract is a fork of the [Balancer Pool](https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol). The primary changes made to the contract were to enable more dynamic pool management so that assets can be bound, rebound and reweighed gradually and without the need to access external liquidity.\n\n<!-- ## Terminology\n\n- **Underlying Tokens** - The tokens held by the pool which represent its portfolio.\n- **Weight** - The proportion of the pool value represented by a single token.\n- **Target Weight** - The weight of a token set by the pool controller which the pool will gradually move the actual weight towards.\n- **Desired Tokens** - Tokens with a target weight above zero.\n- **Undesired Tokens** - Tokens with a target weight of zero.\n- **Re-index** - The process of adjusting both the desired tokens and their weights.\n- **Re-weigh** - The process of adjusting the target weights of the current desired tokens in a pool. -->\n\n<!-- ## Token Weights\nEvery token $$t$$ in a pool has an associated weight $$W_t$$ and balance $$B_t$$. A token's normalized weight represents the total value of the pool which is held in the balance of that token, where the normalized weight is the token's denormalized weight divided by the total weight. These two values are used to price swaps between tokens - the spot price between token $$i$$ and token $$o$$ is given by the formula:\n\n$$\nSP_{i}^{o} = \\frac{B_i/W_i}{B_o/W_o} \\cdot \\frac{1}{1-fee}\n$$ -->\n\n> It may be useful to read the Balancer [Whitepaper](https://balancer.finance/whitepaper/) or [documentation](https://docs.balancer.finance/) for additional context on the pool contract.\n\n# Rebalancing\n\nThe typical method for rebalancing a token portfolio is to sell and purchase sufficient amounts of each asset to reach the desired weights. This typically involves trading with on-chain exchanges or using an auction system. Any method of swapping on-chain to rebalance will cause some amount of loss for the pool, potentially quite a lot. On-chain exchanges are illiquid, and auctions on Ethereum [have a history of being exploited](https://forum.makerdao.com/t/black-thursday-response-thread/1433).\n\nIndex pools rebalance themselves over time by creating small arbitrage opportunities that incentivize traders to gradually adjust token balances and weights. As tokens are swapped, their weights move slightly toward the targets set by the pool controller. This weight adjustment occurs at a maximum of once per hour in order to create small arbitrage opportunities over time that eventually bring the portfolio composition in line with the targets.\n\nWhile this rebalancing process is not instantaneous, it is permissionless, it works for arbitrarily large pools, it is generally more gas efficient and it does not assume that the pool or its controller can access external liquidity to execute rebalances.\n\nFor further details on the rebalancing process, see [Rebalancing](./rebalancing/index.md).\n\n# Limitations\n\n**Abnormal token implementations**\n\nTokens that have internal transfer fees or other non-standard balance updates may create arbitrage opportunities. For now, these tokens should not be used in Indexed pools. Indexed pools do not have the same ERC20 restrictions on return values as Balancer pools, as the pool contract uses methods from OpenZeppelin's `SafeERC20` library.\n\n**Permanent loss for some liquidity providers due to unbound token handling**\n\nWhile the selling of a pool's unbound tokens is restricted to a small range around their moving average prices, it is still possible for a liquidity provider to experience permanent loss due to the way that unbound tokens are handled. If an LP exits a pool after a token is removed from the pool, but before its balance is swapped to the other underlying assets, the LP will suffer a loss of around 1% of their pool tokens' value (as 1% is the minimum weight of the pool).\n\n**Swap input amount**\n\nWhen a token is sold to a pool, the input amount can not exceed half of the pool's current balance in that token. This restriction applies to swaps and single-asset liquidity providing functions, but does not apply to all-asset liquidity providing. This only applies to an individual call to the contract, and can be bypassed with multiple calls.\n\n**Swap output amount**\n\nWhen a token is purchased from a pool, the output amount can not exceed one third of the pool's current balance in that token. This restriction applies to swaps and single-asset liquidity removal functions, but does not apply to all-asset liquidity removal. This only applies to an individual call to the contract, and can be bypassed with multiple calls.\n\n**Minimum balance**\n\nWhen a pool is first initialized, it must have a balance of at least 1e6 wei. This does not apply to tokens after the pool is initialized",
  "docs/protocol/rebalancing/adding-tokens": "# Bootstrapping new tokens\n\nWhen the pool is deployed, every token in the initial asset pool must be added with sufficient tokens to cover its weight. The balance and weight for a token are used to price that token relative to the other assets in a pool, so it is important that token balances be representative of their weight.\n\nIf we simply add a new token to the pool with an arbitrary weight and no balance, it will eventually reach that weight as a result of arbitrage. However, this would obviously cause massive losses for liquidity providers who are paying exorbitant rates for the new token. Instead, we added a couple of changes to the Balancer pool contract so that tokens with no balance can be priced into swaps and joins.\n\n## False Weight & Balance\n\nWhen tokens are first added, they are assigned a minimum balance which represents the number of tokens needed to be worth 1% of the pool's portfolio. The minimum balance and minimum weight (1/100) are used to price the token relative to the other assets in the pool.\n\n## Limitations\n\nThe exact total weight of the pool can vary slightly as the result of weight adjustments, new tokens might have external price changes before they are initialized, and the value of the pool can change as a result of liquidity provider exits and joins. Given the low value of uninitialized token as a proportion of the pool, overpricing them is less of a problem than underpricing them, as the former can not cause much loss to the pool but the latter can result in a token failing to meet its balance target. If a token's price drastically increases on external markets before the pool reaches the minimum balance for that token, the minimum balance can be updated by the pool controller.\n\n## Restrictions\n\nEach token in the pool is assigned a `ready` boolean field which indicates whether the token is fully initialized (meaning the pool's balance of that token is representative of its weight). When new tokens are added that the pool has no balance in, they are marked as uninitialized (`ready = false`). If a token is not ready, it can only be bought by the pool or acquired through LP joins, it can not exit the pool. Swaps that try to buy the token and LP exits that try to claim the token will revert.\n\n## Price Premium\n\nA slight premium is paid on new tokens based on how close they are to their minimum balances in order to incentivize faster initialization. The premium starts out at roughly 10% and decreases as a token gets closer to its minimum. The weight including the premium is calculated with:\n\n$$W_t^u = W_{min} \\cdot \\left(1 + \\frac{B_{t}^{min} - B_{t}}{10 \\cdot B_{t}^{min}}\\right)$$\n\n## Initialization\n\nWhen a token reaches its minimum balance, it is marked as ready and its weight is set. Unlike other weight changes which modify weights by 1% per hour, when a token is initialized its weight will be set to the minimum weight plus a factor proportional to the amount it exceeded the minimum balance. The reason for this is that tokens with low weights are subject to larger price fluctuations, and it is possible to swap in up to 50% of the current balance the pool holds in some token. If the token's balance is substantially higher than its weighted proportion of the pool value, it will be priced lower than it should and people will have an incentive to buy it from the pool, even though we are looking to increase the pool balance of that token.\n\nThe weight factor is: $$\\frac{W_{min} \\cdot \\left( B_{t} - B_{t}^{min}\\right)}{B_{t}^{min}}$$ so when the token is initialized, its weight is set to $$W_{min} \\cdot \\frac{1 + \\left(B_{t} - B_{t}^{min}\\right)}{B_{t}^{min}}$$ where $$B_{t}$$ is the pool's balance in that token including the amount gained in the transaction.\n",
  "docs/protocol/rebalancing/index": "# Rebalancing\n\n## Re-weighing assets\n\nPools can be re-weighed to adjust the composition of the *current desired tokens* in the pool. The current desired tokens are the underlying tokens in the pool with a target weight greater than zero. Re-weighing a pool adjusts the target weights of each asset but does not remove or add tokens.\n\n## Re-indexing assets\n\nPools can be re-indexed to adjust both the underlying tokens and their target weights.\n\nAny current underlying tokens which are not assigned a new target weight in the re-index call will be assigned a target weight of 0 so that they can be gradually removed from the pool. If this occurs for a token which is bound but not initialized, the token will be unbound (see [unbound token handling](./removing-tokens.md#Handling-unbound-tokens)).\n\nNew tokens added to the pool must be assigned a minimum balance which is roughly equal to 1% of the total pool value (see [bootstrapping new tokens](./adding-tokens.md)) .\n\n## Weight Adjustment\n\nIn order to rebalance through internal swaps, Indexed uses a *desired weight* ($$D_t$$) parameter which defines the target weight for an asset. If a desired weight is higher than the actual weight, the pool should increase its balance in that token. If the desired weight is lower than the actual weight, the pool should decrease its balance in that token.\n\nEach pool has a minimum update delay, which by default is 1 hour, and a weight change factor, which by default is 1%. \n\nIf a token with a positive weight difference ($$D_t > W_t$$) is swapped into the pool and it has been more than the minimum delay period since its last weight change, the pool will increase that token's weight by either the weight change factor or the token's desired weight, whichever is less.\n\n```js\nconst weightChangeFactor = 0.01;\n\nupdateWeightIn(tokenIn) {\n  if (tokenIn.desiredWeight > tokenIn.weight) {\n    tokenIn.weight = Math.min(\n      tokenIn.desiredWeight,\n      tokenIn.weight * (1 + weightChangeFactor)\n    )\n  }\n}\n```\n\nIf a token with a negative weight difference ($$D_t < W_t$$) is swapped out of the pool and it has been more than the minimum delay period since its last weight change, the pool will decrease that token's weight by either the weight change factor or the token's desired weight, whichever is less.\n\n```js\nconst weightChangeFactor = 0.01;\n\nupdateWeightOut(tokenOut) {\n  if (tokenOut.desiredWeight < tokenOut.weight) {\n    tokenOut.weight = Math.max(\n      tokenOut.desiredWeight,\n      tokenOut.weight * (1 - weightChangeFactor)\n    )\n  }\n}\n```\n\nAs swaps are executed and LP tokens are minted and burned, inbound tokens with desired weight increases (desired > real) and outbound tokens with desired weight decreases (real > desired) automatically adjust their weights, occasionally creating small arbitrage opportunities which move tokens toward their target balances when traders execute on them, thus rebalancing the pool.\n\n**Note:** There are two exceptions to the stated weight adjustment rule:\n\n1. The `exitPool` function, which sends out some amount of every initialized token. In order to minimize gas expenditure, this function does not adjust the weights of outbound tokens.\n2. When an uninitialized token becomes ready, the weight can increase beyond the fee factor<sup>[1](#Initialization)</sup>.",
  "docs/protocol/rebalancing/removing-tokens": "# Removing Tokens\n\nIf a token in an index pool has a target weight of zero, the pool should remove the token from its portfolio. This is done gradually through the rebalancing process until the token reaches the minimum weight.\n\nWhen a token's weight reaches the minimum (roughly 1%), the price changes that occur as the result of swaps become more dramatic and begin to expose the pool to unintended loss. Rather than continuing the gradual weight adjustment until the token is completely gone, once a token reaches the minimum weight the pool will transfer the remaining balance to an *unbound token handler* contract which is deployed for each pool.\n\nAdditionally, if the `gulp` function on a pool is called for a token which is not bound to the pool, the pool's balance of that token will be sent to the unbound token handler.\n\n## Handling Unbound Tokens\n\nCurrently, the only contract for handling unbound tokens is [UnboundTokenSeller.sol](../../smart-contracts/token-seller.md). A new unbound token seller contract is deployed as a proxy for each index pool. The contract receives unbound tokens from a pool and sells them for the desired underlying tokens in the pool (tokens with a non-zero target weight).\n\n### Token Pricing\n\nThe token seller uses the [Uniswap price oracle](../price-oracles.md) to determine the hourly moving average prices of tokens being swapped. It is configured with a `premiumPercent` value that gives an advantage to token buyers by reducing the output value it expects for a given input value.\n\nExample: if the seller has `premiumPercent = 5` and owns 10 A tokens with an average price of 1 ETH on UniSwap, and someone wants to purchase them for B tokens with an average price of 2 ETH on UniSwap, the contract will accept 4.75 B (worth 9.5 ETH) for 10 A (worth 10 ETH).\n\n### UniSwap Trades\n\nUsers can call the contract to trigger a UniSwap trade between a token it holds and a token the pool will accept. For UniSwap trades, any output tokens the contract receives beyond the minimum are paid to the caller as a reward for triggering the swap.\n\n### User Trades\n\nUsers can call the contract to trade with it directly. For these trades, the contract will always take the minimum output or pay the maximum input, depending on whether the user calls to swap an exact input or output amount.",
  "docs/protocol/security": "# Security\n\nBecause of limited availability, the NDX contracts have not been audited by an established security firm; however, the core contracts have been audited by two independent security experts: Daniel Luca, a former auditor for Consensys diligence, and Mudit Gupta, the lead blockchain engineer at Polymath.\n- [Daniel Luca's Audit Report](https://github.com/monoceros-alpha/audit-indexed-finance-2020-10)\n- [Mudit Gupta's Audit Report](https://github.com/maxsam4/indexed-finance-review)\n\n## Risks\n\nIt is important for users to understand that the NDX governance organization, which the team will hold majority control of until the initial distribution is complete, has the ability to change the proxy implementation for most core contracts in the Indexed protocol. All governance transactions are subject to a two day time lock, so careful users should [monitor proposals submitted to the governor contract](https://etherscan.io/address/0x95129751769f99CC39824a0793eF4933DD8Bb74B#code).\n\n## Warning\n\nThis project is still in beta and we advise caution - please do not put more into our contracts than you are prepared to lose if a vulnerability is found and exploited.\n\nWe are confident in the security of our contracts and have sought third-party opinions, but since the project is new and has not received extensive scrutiny from hackers or auditing firms, we can not be absolutely certain that no mistakes were overlooked.",
  "docs/protocol/terminology": "# Terminology\n\n- **Weight** - The proportion of a pool's total value which a token represents.\n- **Denormalized Weight** - The denormalized weight value. Solidity does not have good handling for fixed point numbers, so the contracts uses denormalized values to represent token weights.\n- **Target Weight** - The weight that a pool's controller has determined a token should eventually have, and which swaps will move the token towards. Used interchangeably with \"desired weight\".\n- **Initialized** - Used to describe whether a pool owns a sufficient amount of a token to cover the minimum weight<sup>[1](./pools/adding-tokens.md)</sup>.\n  - **Note:** this is distinct from \"pool initialization\", which acts in the place of a constructor.\n- **Portfolio** - The basket of assets held by a pool.\n- **Portfolio Composition** - The makeup of a portfolio, particularly with regard to the weights of each token.\n- **Underlying Tokens** - The tokens held by a pool.\n- **Index Tokens** - Liquidity provider tokens for a pool. These represent ownership of the underlying assets in a pool.\n- **Rebalance** - The process of changing the composition of an index pool.\n- **Re-weigh** - The process of re-assigning the target weights of the current desired tokens in an index pool.\n- **Re-index** - The process of re-assigning both the desired tokens in an index pool and their target weights.",
  "docs/smart-contracts/controller": "# `MarketCapSqrtController`\n\nThis contract implements the market cap square root index management strategy.\n\nCategories are periodically sorted, ranking their tokens in descending order by market cap.\n\nIndex pools have a defined size which is used to select the top tokens from the pool's category. Every 2 weeks, pools are either re-weighed or re-indexed. They are re-indexed once for every three re-weighs.\n\nRe-indexing involves selecting the top tokens from the pool's category and weighing them by the square root of their market caps. Re-weighing involves weighing the tokens which are already indexed by the pool by the square root of their market caps. When a pool is re-weighed, only the tokens with a desired weight above 0 are included.\n\n## `constructor` \n\n```\nconstructor(\n  UniSwapV2PriceOracle oracle,\n  address ndx,\n  PoolFactory factory,\n  DelegateCallProxyManager proxyManager\n)\n```\n\nDeploy the controller and configure the addresses\nof the related contracts.\n\n# Controls\n\n## `setOwner` \n\n```\nfunction setOwner(address owner)\n```\n\n\n\nSet the address of the ndx contract.\nAfter deployment this will likely never change, but it is useful\nto have some small window during which things can be initialized\nbefore governance is fully in place.\n\n## `setDefaultSellerPremium` \n\n```\nfunction setDefaultSellerPremium(uint8 _defaultSellerPremium)\n```\n\n\n\nSets the default premium rate for token seller contracts.\n\n## `emergencyExecuteSwapTokensForExactTokens` \n\n```\nfunction emergencyExecuteSwapTokensForExactTokens(\n  address sellerAddress,\n  address tokenIn,\n  address tokenOut,\n  uint256 maxAmountIn,\n  uint256 amountOut,\n  address[] path\n)\n```\n\nEmergency function that allows the dao to force a token sale\nthrough UniSwap. This exists in case of an emergency which demands\nimmediate removal of a token.\n\n# Pool Deployment\n\n## `prepareIndexPool` \n\n```\nfunction prepareIndexPool(\n  uint256 categoryID,\n  uint256 indexSize,\n  uint256 initialWethValue,\n  string name,\n  string symbol\n)\n```\n\nDeploys an index pool and a pool initializer.\nThe initializer contract is a pool with specific token\nbalance targets which gives pool tokens in the finished\npool to users who provide the underlying tokens needed\nto initialize it.\n\n## `finishPreparedIndexPool` \n\n```\nfunction finishPreparedIndexPool(\n  address poolAddress,\n  address[] tokens,\n  uint256[] balances\n)\n```\n\nInitializes a pool which has been deployed but not initialized\nand transfers the underlying tokens from the initialization pool to\nthe actual pool.\n\n# Pool Management\n\n## `updateSellerPremiumToDefault` \n\n```\nfunction updateSellerPremiumToDefault(\n  address sellerAddress\n)\n```\n\n\n\nUpdate the premium rate on `sellerAddress` with the current\ndefault rate.\n\n## `updateSellerPremiumToDefault` \n\n```\nfunction updateSellerPremiumToDefault(\n  address[] sellerAddresses\n)\n```\n\n\n\nUpdate the premium rate on each unbound token seller in\n`sellerAddresses` with the current default rate.\n\n## `setSwapFee` \n\n```\nfunction setSwapFee(address poolAddress, uint256 swapFee)\n```\n\n\n\nSets the swap fee on an index pool.\n\n## `pausePublicTrading` \n\n```\nfunction pausePublicTrading(address poolAddress)\n```\n\n\n\nFreezes public trading and liquidity providing on an index pool.\n\n## `resumePublicTrading` \n\n```\nfunction resumePublicTrading(address poolAddress)\n```\n\n\n\nResumes public trading and liquidity providing on an index pool.\n\n## `removeTokenFromPool` \n\n```\nfunction removeTokenFromPool(\n  address poolAddress, \n  address tokenAddress\n)\n```\n\nForcibly removes a token from a pool.\nThis should only be used as a last resort if a token is experiencing\na sudden crash or major vulnerability. Otherwise, tokens should only\nbe removed gradually through re-indexing events.\n\n# Category Management\n\n## `createCategory` \n\n```\nfunction createCategory(bytes32 metadataHash)\n```\n\n\n\nCreate a new token category.\n\n\n## `addToken` \n\n```\nfunction addToken(address token, uint256 categoryID)\n```\n\n\n\nAdds a new token to a category.\nNote: A token can only be assigned to one category at a time.\n\n## `addTokens` \n\n```\nfunction addTokens(uint256 categoryID, address[] tokens)\n```\n\nAdd tokens to a category.\n\n\n## `orderCategoryTokensByMarketCap` \n\n```\nfunction orderCategoryTokensByMarketCap(uint256 categoryID, address[] orderedTokens)\n```\n\n\n\nSorts a category's tokens in descending order by market cap.\nVerifies the order of the provided array by querying the market caps.\n\n# Pool Rebalancing\n\n## `reindexPool` \n\n```\nfunction reindexPool(address poolAddress)\n```\n\n\n\nRe-indexes a pool by setting the underlying assets to the top\ntokens in its category by market cap.\n\n## `reweighPool` \n\n```\nfunction reweighPool(address poolAddress)\n```\n\n\n\nReweighs the assets in a pool by market cap and sets the\ndesired new weights, which will be adjusted over time.\n\n## `setMinimumBalance` \n\n```\nfunction setMinimumBalance(\n  IPool pool,\n  address tokenAddress\n)\n```\n\nUpdates the minimum balance of an uninitialized token, which is\nuseful when the token's price on the pool is too low relative to\nexternal prices for people to trade it in.\n\n# Pool Queries\n\n# `defaultSellerPremium`\n\n```\nfunction defaultSellerPremium() returns (uint256 defaultSellerPremium)\n```\n\nDefault premium percent for index pool's unbound token sellers.\n\n## `computeInitializerAddress` \n\n```\nfunction computeInitializerAddress(address poolAddress) returns (address initializerAddress)\n```\n\n\n\nCompute the create2 address for a pool initializer.\n\n## `computePoolAddress` \n\n```\nfunction computePoolAddress(uint256 categoryID, uint256 indexSize) returns (address poolAddress)\n```\n\nCompute the create2 address for a pool.\n\n## `getInitialTokenWeightsAndBalances` \n\n```\nfunction getInitialTokenWeightsAndBalances(\n  uint256 categoryID,\n  uint256 indexSize,\n  uint256 wethValue\n) returns (address[] tokens, uint96[] denormalizedWeights, uint256[] balances)\n```\n\nQueries the top `indexSize` tokens in a category from the market _oracle, computes their relative weights by market cap square root and determines the weighted balance of each token to meet a specified total value in weth.\n\n## `getInitialTokensAndBalances` \n\n```\nfunction getInitialTokensAndBalances(\n  uint256 categoryID,\n  uint256 indexSize,\n  uint256 wethValue\n) returns (address[] tokens, uint256[] balances)\n```\n\nQueries the top `indexSize` tokens in a category from the market _oracle, computes their relative weights by market cap square root and determines the weighted balance of each token to meet a specified total value.\n\n# Market Cap Queries\n\n## `computeAverageMarketCap` \n\n```\nfunction computeAverageMarketCap(\n  address token\n) returns (uint144 marketCap)\n```\n\nCompute the average market cap of a token in WETH.\nQueries the average amount of ether that the total supply is worth\nusing the recent moving average.\n\n## `computeAverageMarketCaps` \n\n```\nfunction computeAverageMarketCaps(\n  address[] tokens\n) returns (uint144[] marketCaps)\n```\n\nReturns the average market cap for each token.\n\n# Category Queries\n\n## `categoryIndex`\n\n```\nfunction categoryIndex() returns (uint256 categoryID)\n```\n\nNumber of categories in the oracle.\n\n## `hasCategory` \n\n```\nfunction hasCategory(uint256 categoryID) returns (bool)\n```\n\nReturns a boolean stating whether a category exists.\n\n## `getCategoryTokens` \n\n```\nfunction getCategoryTokens(\n  uint256 categoryID\n) returns (address[] tokens)\n```\n\n\n\nReturns the array of tokens in a category.\n\n## `getCategoryMarketCaps` \n\n```\nfunction getCategoryMarketCaps(\n  uint256 categoryID\n) returns (uint144[] marketCaps)\n```\n\n\n\nReturns the market capitalization rates for the tokens\nin a category.\n\n## `getTopCategoryTokens` \n\n```\nfunction getTopCategoryTokens(\n  uint256 categoryID,\n  uint256 num\n) returns (address[] tokens)\n```\n\nGet the top `num` tokens in a category.\nNote: The category must have been sorted by market cap\nin the last `MAX_SORT_DELAY` seconds.\n",
  "docs/smart-contracts/deployments": "# Smart Contract Deployments\n\n# Governance\n\n| Contract      | Link |\n| ----------- | ----------- |\n| GovernorAlpha | [0x95129751769f99CC39824a0793eF4933DD8Bb74B](https://etherscan.io/address/0x95129751769f99CC39824a0793eF4933DD8Bb74B#code) |\n| NDX | [0x86772b1409b61c639EaAc9Ba0AcfBb6E238e5F83](https://etherscan.io/token/0x86772b1409b61c639EaAc9Ba0AcfBb6E238e5F83#code) |\n| Timelock | [0x78a3eF33cF033381FEB43ba4212f2Af5A5A0a2EA](https://etherscan.io/address/0x78a3eF33cF033381FEB43ba4212f2Af5A5A0a2EA#code) |\n\n# Sigma\n\n| Contract      | Link |\n| ----------- | ----------- |\n| CommitteeProxy | [0x08de71d296d3D68a67260e272828428384ECAAd1](https://etherscan.io/address/0x08de71d296d3D68a67260e272828428384ECAAd1#code) |\n| CommitteeTimelock | [0x9BF4bE02414568eb481F448149432c6863737966](https://etherscan.io/token/0x9BF4bE02414568eb481F448149432c6863737966#code) |\n\n# Controllers & Factories\n\n| Contract      | Link |\n| ----------- | ----------- |\n| ProxyManager | [0xd23dedc599bd56767e42d48484d6ca96ab01c115](https://etherscan.io/address/0xd23dedc599bd56767e42d48484d6ca96ab01c115#code) |\n| PoolFactory | [0x592f70ce43a310d15ff59be1460f38ab6df3fe65](https://etherscan.io/address/0x592f70ce43a310d15ff59be1460f38ab6df3fe65#code) |\n| MarketCapSqrtController | [0xF00A38376C8668fC1f3Cd3dAeef42E0E44A7Fcdb](https://etherscan.io/address/0xF00A38376C8668fC1f3Cd3dAeef42E0E44A7Fcdb#code) |\n| SigmaControllerV1 | [0x5b470a8c134d397466a1a603678dadda678cbc29](https://etherscan.io/address/0x5b470a8c134d397466a1a603678dadda678cbc29#code) |\n\n# Access Control\n\n| Contract      | Link |\n| ----------- | ----------- |\n| ProxyManagerAccessControl | [0x3D4860d4b7952A3CAD3Accfada61463F15fc0D54](https://etherscan.io/address/0x3D4860d4b7952A3CAD3Accfada61463F15fc0D54#code) |\n| PoolFactoryAccessControl | [0xb8fdbd8d10b394f85f777969564b6d49d6ebaaa2](https://etherscan.io/address/0xb8fdbd8d10b394f85f777969564b6d49d6ebaaa2#code) |\n\n# Distribution\n\n| Contract      | Link |\n| ----------- | ----------- |\n| StakingRewardsFactory | [0x48887E27e3E42e769F34e1e43E857235035d333a](https://etherscan.io/address/0x48887E27e3E42e769F34e1e43E857235035d333a#code) |\n| TreasuryLock | [0xE504AFA01c7d5154778C0d93D6fb9BdBb6Bf2A52](https://etherscan.io/address/0xE504AFA01c7d5154778C0d93D6fb9BdBb6Bf2A52#code) |\n| TreasuryVesting | [0xdaafbE65784f93ea0747173a77abB4206f98443C](https://etherscan.io/address/0xdaafbE65784f93ea0747173a77abB4206f98443C#code) |\n| Team Vesting | [0x8d12a344580bc0bc4e684248067f5d9d3908c864](https://etherscan.io/address/0x8d12a344580bc0bc4e684248067f5d9d3908c864#code) |\n\n# Oracles\n\n| Contract      | Link |\n| ----------- | ----------- |\n| CirculatingMarketCapOracle | [0x7eee24183a36c84130d22db16f01d593114a8391](https://etherscan.io/address/0x7eee24183a36c84130d22db16f01d593114a8391#code) |\n| IndexedUniswapV2Oracle | [0xFa5a44D3Ba93D666Bf29C8804a36e725ecAc659A](https://etherscan.io/address/0xFa5a44D3Ba93D666Bf29C8804a36e725ecAc659A#code) |\n\n# Scoring Strategies\n\n| Contract      | Link |\n| ----------- | ----------- |\n| ScoreBySqrtCMC | [0x9942A2ead03DB203Afb3443B24A0859a60513542](https://etherscan.io/address/0x9942A2ead03DB203Afb3443B24A0859a60513542#code) |\n\n# Proxy Implementations\n\n| Contract      | Link | Implementation ID |\n| ----------- | ----------- | ----------- | \n| SigmaControllerV1 | [0x954Fb82051842b4e42256da8A37C7750DF31d6E0](https://etherscan.io/address/0x954Fb82051842b4e42256da8A37C7750DF31d6E0#code) | 0x70219b4d0979ac275f248dae0d8446aa805f21b4f187cd25919f3b14ed692b28 |\n| SigmaIndexPoolV1 | [0x0c64034984293EB44f0aD19bb48E7a8d3aC05e94](https://etherscan.io/address/0x0c64034984293EB44f0aD19bb48E7a8d3aC05e94#code) | 0x42fdd905bf1f3fac3b475cdca7cc127db3a757ae179f57c9da3b4787f5f58206 |\n| SigmaPoolInitializerV1 | [0xddD355896c9F99eB794d6E5203c20C24FB255478](https://etherscan.io/address/0xddD355896c9F99eB794d6E5203c20C24FB255478#code) | 0xe3d7c1179cc3f4ae9aab4e39c8923b411d4674dcb3d44aa456301be51bb24aef |\n| SigmaUnboundTokenSellerV1 | [0x5b713D86D687eC53D6B9Ad7564f8CEbDFa5a7419](https://etherscan.io/address/0x5b713D86D687eC53D6B9Ad7564f8CEbDFa5a7419#code) | 0x9f8b000e870cb32f9827cf46e6a69e2637d6c7131de0898cec5106d029b20f8d |",
  "docs/smart-contracts/initializer": "## `PoolInitializer`\n\nContract that acquires the initial balances for an index pool.\n\nThis uses a short-term UniSwap price oracle to determine the ether value of tokens sent to the contract. When users contribute tokens they are credited for the moving average ether value of said tokens.\n\nWhen all the tokens needed are acquired, the index pool will be initialized and this contract will receive the initial token supply (100).\n\nOnce the contract receives the index pool tokens, users can claim their share of the tokens proportional to their credited contribution value.\n\n# Start and Finish\n\n## `initialize` \n\n```\nfunction initialize(\n  address poolAddress,\n  address[] tokens,\n  uint256[] amounts\n)\n```\n\nSets the initializer's pool address and desired token amount.\n\n## `finish` \n\n```\nfunction finish()\n```\n\nFinishes the pool initializer and triggers pool initialization.\n\n**Notes**\n\nThe desired amounts of all tokens must be 0.\n\n# Token Claims\n\n## `claimTokens` \n\n```\nfunction claimTokens()\n```\n\nClaims the tokens owed to `msg.sender` based on their proportion of the total credits.\n\n## `claimTokens` \n\n```\nfunction claimTokens(address account)\n```\n\nClaims the tokens owed to `account` based on their proportion\nof the total credits.\n\n## `claimTokens` \n\n```\nfunction claimTokens(address[] accounts)\n```\n\n\n\nClaims the tokens owed to `account` based on their proportion\nof the total credits.\n\n# Token Contribution\n\n## `contributeTokens` \n\n```\nfunction contributeTokens(\n  address token,\n  uint256 amountIn,\n  uint256 minimumCredit\n) returns (uint256 credit)\n```\n\nContribute up to `amountIn` of `token` to the pool for credit.\n\nThe caller will be credited for the average weth value of the provided\ntokens.\n\n**Notes**\n\nCaller must receive at least `minimumCredit` to not revert.\nIf `amountIn` is greater than the desired amount of `token`, the\ndesired amount will be used instead. \n\n## `contributeTokens` \n\n```\nfunction contributeTokens(\n  address[] tokens,\n  uint256[] amountsIn,\n  uint256 minimumCredit\n) returns (uint256 credit)\n```\n\nContribute maximum values from `amountsIn` of the corresponding\ntokens in `tokens` to the pool for credit.\n\nThe caller will be credited for the average weth value of the provided\ntokens.\n\nCaller must receive at least `minimumCredit` to not revert.\nIf any input amount is greater than the desired amount of the corresponding\ntoken, the desired amount will be used instead.\n\n# Price Updates\n\n## `updatePrices` \n\n```\nfunction updatePrices()\n```\n\nUpdates the prices of all desired tokens on the price oracle.\n\n# Status Queries\n\n## `isFinished`\n\n```\nfunction isFinished() returns (bool)\n```\n\nReturns whether the pool has been initialized.\n\n# Credit Queries\n\n## `getTotalCredit`\n\n```\nfunction getTotalCredit() returns (uint256)\n```\n\nReturns the total value credited for token contributions.\n\n\n## `getCreditOf`\n\n```\nfunction getCreditOf(address account) returns (uint256)\n```\n\nReturns the amount of credit owed to `account`.\n\n# Token Queries\n\n## `getDesiredTokens` \n\n```\nfunction getDesiredTokens() returns (address[] tokens)\n```\n\nReturns the array of desired tokens.\n\n\n## `getDesiredAmount` \n\n```\nfunction getDesiredAmount(address token) returns (uint256)\n```\n\nReturns the remaining amount of `token` the pool needs.\n\n\n## `getCreditForTokens` \n\n```\nfunction getCreditForTokens(\n  address token,\n  uint256 amountIn\n) returns (uint144 amountOut)\n```\n\nReturns the amount of WETH the contract will credit a user for providing `amountIn` of `token`.\n\n**Notes**\n\nIf `amountIn` is greater than the desired amount of `token`, this will calculate the output using the desired amount instead of `amountIn`.\n\n",
  "docs/smart-contracts/interfaces/IFlashLoanRecipient": "```\npragma solidity ^0.6.0;\n\ninterface IFlashLoanRecipient {\n  function receiveFlashLoan(bytes calldata data) external;\n}\n```",
  "docs/smart-contracts/interfaces/IIndexPool": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IIndexPool {\n  /**\n   * @dev Token record data structure\n   * @param bound is token bound to pool\n   * @param ready has token been initialized\n   * @param lastDenormUpdate timestamp of last denorm change\n   * @param denorm denormalized weight\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\n   * @param index index of address in tokens array\n   * @param balance token balance\n   */\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  event LOG_TOKEN_REMOVED(address token);\n\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  event LOG_TOKEN_READY(address indexed token);\n\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external;\n\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler\n  ) external;\n\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\n\n  function setSwapFee(uint256 swapFee) external;\n\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  ) external;\n\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  ) external;\n\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256/* poolAmountOut */);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256/* tokenAmountIn */);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external returns (uint256/* tokenAmountOut */);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256/* poolAmountIn */);\n\n  function gulp(address token) external;\n\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\n\n  function isPublicSwap() external view returns (bool);\n\n  function getSwapFee() external view returns (uint256/* swapFee */);\n\n  function getController() external view returns (address);\n\n  function getMaxPoolTokens() external view returns (uint256);\n\n  function isBound(address t) external view returns (bool);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\n\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\n\n  function getTokenRecord(address token) external view returns (Record memory record);\n\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getMinimumBalance(address token) external view returns (uint256);\n\n  function getUsedBalance(address token) external view returns (uint256);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\n}",
  "docs/smart-contracts/interfaces/index": "Contract Interfaces",
  "docs/smart-contracts/oracle/IndexedUniswapV2Oracle": "# `IndexedUniswapV2Oracle`\n\n\n\n\n\n# Functions:\n- [`constructor(address uniswapFactory, address weth)`](#IndexedUniswapV2Oracle-constructor-address-address-)\n- [`updatePrice(address token)`](#IndexedUniswapV2Oracle-updatePrice-address-)\n- [`updatePrices(address[] tokens)`](#IndexedUniswapV2Oracle-updatePrices-address---)\n- [`hasPriceObservationInWindow(address token, uint256 priceKey)`](#IndexedUniswapV2Oracle-hasPriceObservationInWindow-address-uint256-)\n- [`getPriceObservationInWindow(address token, uint256 priceKey)`](#IndexedUniswapV2Oracle-getPriceObservationInWindow-address-uint256-)\n- [`getPriceObservationsInRange(address token, uint256 timeFrom, uint256 timeTo)`](#IndexedUniswapV2Oracle-getPriceObservationsInRange-address-uint256-uint256-)\n- [`canUpdatePrice(address token)`](#IndexedUniswapV2Oracle-canUpdatePrice-address-)\n- [`canUpdatePrices(address[] tokens)`](#IndexedUniswapV2Oracle-canUpdatePrices-address---)\n- [`computeTwoWayAveragePrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeTwoWayAveragePrice-address-uint256-uint256-)\n- [`computeAverageTokenPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageTokenPrice-address-uint256-uint256-)\n- [`computeAverageEthPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageEthPrice-address-uint256-uint256-)\n- [`computeTwoWayAveragePrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeTwoWayAveragePrices-address---uint256-uint256-)\n- [`computeAverageTokenPrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageTokenPrices-address---uint256-uint256-)\n- [`computeAverageEthPrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageEthPrices-address---uint256-uint256-)\n- [`computeAverageEthForTokens(address token, uint256 tokenAmount, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageEthForTokens-address-uint256-uint256-uint256-)\n- [`computeAverageTokensForEth(address token, uint256 wethAmount, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageTokensForEth-address-uint256-uint256-uint256-)\n- [`computeAverageEthForTokens(address[] tokens, uint256[] tokenAmounts, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageEthForTokens-address---uint256---uint256-uint256-)\n- [`computeAverageTokensForEth(address[] tokens, uint256[] wethAmounts, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-computeAverageTokensForEth-address---uint256---uint256-uint256-)\n- [`_getTwoWayPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-_getTwoWayPrice-address-uint256-uint256-)\n- [`_getTokenPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-_getTokenPrice-address-uint256-uint256-)\n- [`_getEthPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedUniswapV2Oracle-_getEthPrice-address-uint256-uint256-)\n\n## <a id='IndexedUniswapV2Oracle-constructor-address-address-'></a> `constructor`\n\n```\nfunction constructor(address uniswapFactory, address weth)\n```\n\n## <a id='IndexedUniswapV2Oracle-updatePrice-address-'></a> `updatePrice`\n\n```\nfunction updatePrice(address token) returns (bool)\n```\n\n\n\nAttempts to update the price of `token` and returns a boolean\nindicating whether it was updated.\n\n**Note:** The price can be updated if there is no observation for the current hour\nand at least 30 minutes have passed since the last observation.\n\n\n## <a id='IndexedUniswapV2Oracle-updatePrices-address---'></a> `updatePrices`\n\n```\nfunction updatePrices(address[] tokens) returns (bool[] pricesUpdated)\n```\n\nAttempts to update the price of each token in `tokens` and returns a boolean\narray indicating which tokens had their prices updated.\n\n**Note:** The price can be updated if there is no observation for the current hour\nand at least 30 minutes have passed since the last observation.\n\n\n## <a id='IndexedUniswapV2Oracle-hasPriceObservationInWindow-address-uint256-'></a> `hasPriceObservationInWindow`\n\n```\nfunction hasPriceObservationInWindow(address token, uint256 priceKey) returns (bool)\n```\n\n\n\nReturns a boolean indicating whether a price was recorded for `token` at `priceKey`.\n\n\n### Parameters:\n- `token`: Token to check if the oracle has a price for\n\n- `priceKey`: Index of the hour to check\n\n## <a id='IndexedUniswapV2Oracle-getPriceObservationInWindow-address-uint256-'></a> `getPriceObservationInWindow`\n\n```\nfunction getPriceObservationInWindow(address token, uint256 priceKey) returns (struct PriceLibrary.PriceObservation observation)\n```\n\nReturns the price observation for `token` recorded in `priceKey`.\nReverts if no prices have been recorded for that key.\n\n\n### Parameters:\n- `token`: Token to retrieve a price for\n\n- `priceKey`: Index of the hour to query\n\n## <a id='IndexedUniswapV2Oracle-getPriceObservationsInRange-address-uint256-uint256-'></a> `getPriceObservationsInRange`\n\n```\nfunction getPriceObservationsInRange(address token, uint256 timeFrom, uint256 timeTo) returns (struct PriceLibrary.PriceObservation[] prices)\n```\n\nReturns all price observations for `token` recorded between `timeFrom` and `timeTo`.\n\n\n## <a id='IndexedUniswapV2Oracle-canUpdatePrice-address-'></a> `canUpdatePrice`\n\n```\nfunction canUpdatePrice(address token) returns (bool)\n```\n\n\nReturns a boolean indicating whether the price of `token` can be updated.\n\n**Note:** The price can be updated if there is no observation for the current hour\nand at least 30 minutes have passed since the last observation.\n\n\n## <a id='IndexedUniswapV2Oracle-canUpdatePrices-address---'></a> `canUpdatePrices`\n\n```\nfunction canUpdatePrices(address[] tokens) returns (bool[] canUpdateArr)\n```\n\nReturns a boolean array indicating whether the price of each token in\n`tokens` can be updated.\n\n**Note:** The price can be updated if there is no observation for the current hour\nand at least 30 minutes have passed since the last observation.\n\n\n## <a id='IndexedUniswapV2Oracle-computeTwoWayAveragePrice-address-uint256-uint256-'></a> `computeTwoWayAveragePrice`\n\n```\nfunction computeTwoWayAveragePrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct PriceLibrary.TwoWayAveragePrice)\n```\n\n\n\nReturns the TwoWayAveragePrice struct representing the average price of\nweth in terms of `token` and the average price of `token` in terms of weth.\n\nComputes the time-weighted average price of weth in terms of `token` and the price\nof `token` in terms of weth by getting the current prices from Uniswap and searching\nfor a historical price which is between `minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageTokenPrice-address-uint256-uint256-'></a> `computeAverageTokenPrice`\n\n```\nfunction computeAverageTokenPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112 priceAverage)\n```\n\n\n\nReturns the UQ112x112 struct representing the average price of\n`token` in terms of weth.\n\nComputes the time-weighted average price of `token` in terms of weth by getting the\ncurrent price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageEthPrice-address-uint256-uint256-'></a> `computeAverageEthPrice`\n\n```\nfunction computeAverageEthPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112 priceAverage)\n```\n\nReturns the UQ112x112 struct representing the average price of\nweth in terms of `token`.\n\nComputes the time-weighted average price of weth in terms of `token` by getting the\ncurrent price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeTwoWayAveragePrices-address---uint256-uint256-'></a> `computeTwoWayAveragePrices`\n\n```\nfunction computeTwoWayAveragePrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct PriceLibrary.TwoWayAveragePrice[] prices)\n```\n\nReturns the TwoWayAveragePrice structs representing the average price of\nweth in terms of each token in `tokens` and the average price of each token\nin terms of weth.\n\nComputes the time-weighted average price of weth in terms of each token and the price\nof each token in terms of weth by getting the current prices from Uniswap and searching\nfor a historical price which is between `minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageTokenPrices-address---uint256-uint256-'></a> `computeAverageTokenPrices`\n\n```\nfunction computeAverageTokenPrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112[] averagePrices)\n```\n\nReturns the UQ112x112 structs representing the average price of\neach token in `tokens` in terms of weth.\n\nComputes the time-weighted average price of each token in terms of weth by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageEthPrices-address---uint256-uint256-'></a> `computeAverageEthPrices`\n\n```\nfunction computeAverageEthPrices(address[] tokens, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112[] averagePrices)\n```\n\n\n\nReturns the UQ112x112 structs representing the average price of\nweth in terms of each token in `tokens`.\n\nComputes the time-weighted average price of weth in terms of each token by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageEthForTokens-address-uint256-uint256-uint256-'></a> `computeAverageEthForTokens`\n\n```\nfunction computeAverageEthForTokens(address token, uint256 tokenAmount, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (uint144)\n```\n\n\n\nCompute the average value of `tokenAmount` ether in terms of weth.\nComputes the time-weighted average price of `token` in terms of weth by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by `wethAmount`.\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageTokensForEth-address-uint256-uint256-uint256-'></a> `computeAverageTokensForEth`\n\n```\nfunction computeAverageTokensForEth(address token, uint256 wethAmount, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (uint144)\n```\n\n\n\nCompute the average value of `wethAmount` ether in terms of `token`.\nComputes the time-weighted average price of weth in terms of the token by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by `wethAmount`.\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageEthForTokens-address---uint256---uint256-uint256-'></a> `computeAverageEthForTokens`\n\n```\nfunction computeAverageEthForTokens(address[] tokens, uint256[] tokenAmounts, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (uint144[] averageValuesInWETH)\n```\n\n\n\nCompute the average value of each amount of tokens in `tokenAmounts` in terms\nof the corresponding token in `tokens`.\nComputes the time-weighted average price of each token in terms of weth by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by the corresponding\namount in `tokenAmounts`.\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-computeAverageTokensForEth-address---uint256---uint256-uint256-'></a> `computeAverageTokensForEth`\n\n```\nfunction computeAverageTokensForEth(address[] tokens, uint256[] wethAmounts, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (uint144[] averageValuesInWETH)\n```\n\n\n\nCompute the average value of each amount of ether in `wethAmounts` in terms\nof the corresponding token in `tokens`.\nComputes the time-weighted average price of weth in terms of each token by getting\nthe current price from Uniswap and searching for a historical price which is between\n`minTimeElapsed` and `maxTimeElapsed` seconds old, then multiplies by the corresponding\namount in `wethAmounts`.\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is less than one hour.\n**Note:** `minTimeElapsed` is only accurate to the nearest hour (rounded up) unless\nit is less than one hour.\n\n\n## <a id='IndexedUniswapV2Oracle-_getTwoWayPrice-address-uint256-uint256-'></a> `_getTwoWayPrice`\n\n```\nfunction _getTwoWayPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct PriceLibrary.TwoWayAveragePrice)\n```\n\n\n\n\n\n\n## <a id='IndexedUniswapV2Oracle-_getTokenPrice-address-uint256-uint256-'></a> `_getTokenPrice`\n\n```\nfunction _getTokenPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112)\n```\n\n\n\n\n\n\n## <a id='IndexedUniswapV2Oracle-_getEthPrice-address-uint256-uint256-'></a> `_getEthPrice`\n\n```\nfunction _getEthPrice(address token, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (struct FixedPoint.uq112x112)\n```\n\n\n\n\n\n\n",
  "docs/smart-contracts/oracle/lib/Bits": "# `Bits`\n\n\n\n\n\n# Functions:\n- [`setBit(uint256 self, uint256 index)`](#Bits-setBit-uint256-uint256-)\n- [`bitSet(uint256 self, uint256 index)`](#Bits-bitSet-uint256-uint256-)\n- [`clearBitsAfter(uint256 self, uint256 index)`](#Bits-clearBitsAfter-uint256-uint256-)\n- [`clearBitsBefore(uint256 self, uint256 index)`](#Bits-clearBitsBefore-uint256-uint256-)\n- [`writeSetBits(bytes bitPositions, uint256 val, uint16 offset)`](#Bits-writeSetBits-bytes-uint256-uint16-)\n- [`highestBitSet(uint256 self)`](#Bits-highestBitSet-uint256-)\n- [`lowestBitSet(uint256 self)`](#Bits-lowestBitSet-uint256-)\n- [`nextLowestBitSet(uint256 self, uint256 bit)`](#Bits-nextLowestBitSet-uint256-uint256-)\n- [`nextHighestBitSet(uint256 self, uint256 bit)`](#Bits-nextHighestBitSet-uint256-uint256-)\n\n## <a id='Bits-setBit-uint256-uint256-'></a> `setBit`\n\n```\nfunction setBit(uint256 self, uint256 index) returns (uint256)\n```\n\n\n\nSets the bit at the given 'index' in 'self' to '1'.\nReturns the modified value.\n\n\n## <a id='Bits-bitSet-uint256-uint256-'></a> `bitSet`\n\n```\nfunction bitSet(uint256 self, uint256 index) returns (bool)\n```\n\n\n\nReturns a boolean indicating whether the bit at the given `index` in `self` is set.\n\n\n## <a id='Bits-clearBitsAfter-uint256-uint256-'></a> `clearBitsAfter`\n\n```\nfunction clearBitsAfter(uint256 self, uint256 index) returns (uint256)\n```\n\n\n\nClears all bits in the exclusive range [index:255]\n\n\n## <a id='Bits-clearBitsBefore-uint256-uint256-'></a> `clearBitsBefore`\n\n```\nfunction clearBitsBefore(uint256 self, uint256 index) returns (uint256)\n```\n\n\n\nClears bits in the exclusive range [0:index]\n\n\n## <a id='Bits-writeSetBits-bytes-uint256-uint16-'></a> `writeSetBits`\n\n```\nfunction writeSetBits(bytes bitPositions, uint256 val, uint16 offset)\n```\n\n\n\nWrites the index of every set bit in `val` as a uint16 in `bitPositions`.\nAdds `offset` to the stored bit index.\n`bitPositions` must have a length equal to twice the maximum number of bits that\ncould be found plus 31. Each index is stored as a uint16 to accomodate `offset`\nbecause this is used in functions which would otherwise need expensive methods\nto handle relative indices in multi-integer searches.\nThe specified length ensures that solc will handle memory allocation, and the\naddition of 31 allows us to store whole words at a time.\nAfter being declared, the actual length stored in memory must be set to 0 with:\n`assembly { mstore(bitPositions, 0) }` because the length is used to count found bits.\n\n\n## Parameters:\n- `bitPositions`: Packed uint16 array for positions of set bits\n\n- `val`: Value to search set bits in\n\n- `offset`: Value added to the stored position, used to simplify large searches.\n\n## <a id='Bits-highestBitSet-uint256-'></a> `highestBitSet`\n\n```\nfunction highestBitSet(uint256 self) returns (uint256 r)\n```\n\n\n\nReturns the index of the highest bit set in `self`.\nNote: Requires that `self != 0`\n\n\n## <a id='Bits-lowestBitSet-uint256-'></a> `lowestBitSet`\n\n```\nfunction lowestBitSet(uint256 self) returns (uint256 _z)\n```\n\n\n\nReturns the index of the lowest bit set in `self`.\nNote: Requires that `self != 0`\n\n\n## <a id='Bits-nextLowestBitSet-uint256-uint256-'></a> `nextLowestBitSet`\n\n```\nfunction nextLowestBitSet(uint256 self, uint256 bit) returns (bool haveValueBefore, uint256 previousBit)\n```\n\n\n\nReturns a boolean indicating whether `bit` is the highest set bit\nin the integer and the index of the next lowest set bit if it is not.\n\n\n## <a id='Bits-nextHighestBitSet-uint256-uint256-'></a> `nextHighestBitSet`\n\n```\nfunction nextHighestBitSet(uint256 self, uint256 bit) returns (bool haveValueAfter, uint256 nextBit)\n```\n\n\n\nReturns a boolean indicating whether `bit` is the lowest set bit\nin the integer and the index of the next highest set bit if it is not.\n\n\n",
  "docs/smart-contracts/oracle/lib/IndexedPriceMapLibrary": "# `IndexedPriceMapLibrary`\n\n# Functions:\n- [`toPriceKey(uint256 timestamp)`](#IndexedPriceMapLibrary-toPriceKey-uint256-)\n- [`timeElapsedSinceWindowStart(uint256 timestamp)`](#IndexedPriceMapLibrary-timeElapsedSinceWindowStart-uint256-)\n- [`writePriceObservation(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, struct PriceLibrary.PriceObservation observation)`](#IndexedPriceMapLibrary-writePriceObservation-struct-IndexedPriceMapLibrary-IndexedPriceMap-struct-PriceLibrary-PriceObservation-)\n- [`sufficientDelaySinceLastPrice(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint32 newTimestamp)`](#IndexedPriceMapLibrary-sufficientDelaySinceLastPrice-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint32-)\n- [`canUpdatePrice(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint32 newTimestamp)`](#IndexedPriceMapLibrary-canUpdatePrice-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint32-)\n- [`hasPriceInWindow(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 priceKey)`](#IndexedPriceMapLibrary-hasPriceInWindow-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-)\n- [`getPriceInWindow(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 priceKey)`](#IndexedPriceMapLibrary-getPriceInWindow-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-)\n- [`getPriceObservationsInRange(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 timeFrom, uint256 timeTo)`](#IndexedPriceMapLibrary-getPriceObservationsInRange-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-uint256-)\n- [`getLastPriceObservation(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 timestamp, uint256 minTimeElapsed, uint256 maxTimeElapsed)`](#IndexedPriceMapLibrary-getLastPriceObservation-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-uint256-uint256-)\n\n## <a id='IndexedPriceMapLibrary-toPriceKey-uint256-'></a> `toPriceKey`\n\n```\nfunction toPriceKey(uint256 timestamp) returns (uint256)\n```\n\n\n\nReturns the price key for `timestamp`, which is the hour index.\n\n\n## <a id='IndexedPriceMapLibrary-timeElapsedSinceWindowStart-uint256-'></a> `timeElapsedSinceWindowStart`\n\n```\nfunction timeElapsedSinceWindowStart(uint256 timestamp) returns (uint256)\n```\n\n\n\nReturns the number of seconds that have passed since the beginning of the hour.\n\n\n## <a id='IndexedPriceMapLibrary-writePriceObservation-struct-IndexedPriceMapLibrary-IndexedPriceMap-struct-PriceLibrary-PriceObservation-'></a> `writePriceObservation`\n\n```\nfunction writePriceObservation(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, struct PriceLibrary.PriceObservation observation) returns (bool)\n```\n\nWrites `observation` to storage if the price can be updated. If it is\nupdated, also marks the price key for the observation as having a value in\nthe key index.\n\n**Note:** The price can be updated if there is none recorded for the current\nhour 30 minutes have passed since the last price update.\nReturns a boolean indicating whether the price was updated.\n\n\n## <a id='IndexedPriceMapLibrary-sufficientDelaySinceLastPrice-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint32-'></a> `sufficientDelaySinceLastPrice`\n\n```\nfunction sufficientDelaySinceLastPrice(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint32 newTimestamp) returns (bool)\n```\n\nChecks whether sufficient time has passed since the beginning of the observation\nwindow or since the price recorded in the previous window (if any) for a new price\nto be recorded.\n\n\n## <a id='IndexedPriceMapLibrary-canUpdatePrice-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint32-'></a> `canUpdatePrice`\n\n```\nfunction canUpdatePrice(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint32 newTimestamp) returns (bool)\n```\n\nChecks if a price can be updated. Prices can be updated if there is no price\nobservation for the current hour and at least 30 minutes have passed since the\nobservation in the previous hour (if there is one).\n\n\n## <a id='IndexedPriceMapLibrary-hasPriceInWindow-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-'></a> `hasPriceInWindow`\n\n```\nfunction hasPriceInWindow(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 priceKey) returns (bool)\n```\n\nChecks the key index to see if a price is recorded for `priceKey`\n\n\n## <a id='IndexedPriceMapLibrary-getPriceInWindow-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-'></a> `getPriceInWindow`\n\n```\nfunction getPriceInWindow(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 priceKey) returns (struct PriceLibrary.PriceObservation)\n```\n\n\n\nReturns the price observation for `priceKey`\n\n\n## <a id='IndexedPriceMapLibrary-getPriceObservationsInRange-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-uint256-'></a> `getPriceObservationsInRange`\n\n```\nfunction getPriceObservationsInRange(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 timeFrom, uint256 timeTo) returns (struct PriceLibrary.PriceObservation[] prices)\n```\n\n\n## <a id='IndexedPriceMapLibrary-getLastPriceObservation-struct-IndexedPriceMapLibrary-IndexedPriceMap-uint256-uint256-uint256-'></a> `getLastPriceObservation`\n\n```\nfunction getLastPriceObservation(struct IndexedPriceMapLibrary.IndexedPriceMap indexedPriceMap, uint256 timestamp, uint256 minTimeElapsed, uint256 maxTimeElapsed) returns (bool, uint256)\n```\n\n\n\nFinds the most recent price observation before `timestamp` with a minimum\ndifference in observation times of `minTimeElapsed` and a maximum difference in\nobservation times of `maxTimeElapsed`.\n\n**Note:** `maxTimeElapsed` is only accurate to the nearest hour (rounded down) unless\nit is below one hour.\n\n\n## Parameters:\n- `indexedPriceMap`: Struct with the indexed price mapping for the token.\n\n- `timestamp`: Timestamp to search backwards from.\n\n- `minTimeElapsed`: Minimum time elapsed between price observations.\n\n- `maxTimeElapsed`: Maximum time elapsed between price observations.\nOnly accurate to the nearest hour (rounded down) unless it is below 1 hour.\n\n",
  "docs/smart-contracts/oracle/lib/KeyIndex": "# `KeyIndex`\n\n\n\nLibrary for indexing keys stored in a sequential mapping for easier\nqueries.\nEvery set of 256 keys in the value map is assigned a single index which\nrecords set values as bits, where 1 indicates the map has a value at a given\nkey and 0 indicates it does not.\n\nThe 'value map' is the map which stores the values with sequential keys.\n\nThe 'key index' is the mapping which stores the indices for each 256 values\nin the map. For example, the key '256' in the value map would have a key\nin the key index of `1`, where the 0th bit in the index records whether a\nvalue is set in the value map .\n\n# Functions:\n- [`toMapKey(uint256 indexKey, uint256 indexPosition)`](#KeyIndex-toMapKey-uint256-uint256-)\n- [`indexKeyAndPosition(uint256 mapKey)`](#KeyIndex-indexKeyAndPosition-uint256-)\n- [`markSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey)`](#KeyIndex-markSetKey-mapping-uint256----uint256--uint256-)\n- [`hasKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey)`](#KeyIndex-hasKey-mapping-uint256----uint256--uint256-)\n- [`getEncodedSetKeysInRange(mapping(uint256 => uint256) keyIndex, uint256 mapKeyFrom, uint256 mapKeyTo)`](#KeyIndex-getEncodedSetKeysInRange-mapping-uint256----uint256--uint256-uint256-)\n- [`findLastSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey, uint256 maxDistance)`](#KeyIndex-findLastSetKey-mapping-uint256----uint256--uint256-uint256-)\n- [`findNextSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey, uint256 maxDistance)`](#KeyIndex-findNextSetKey-mapping-uint256----uint256--uint256-uint256-)\n\n## <a id='KeyIndex-toMapKey-uint256-uint256-'></a> `toMapKey`\n\n```\nfunction toMapKey(uint256 indexKey, uint256 indexPosition) returns (uint256)\n```\n\n\n\nCompute the map key for a given index key and position.\nMultiplies indexKey by 256 and adds indexPosition.\n\n\n## <a id='KeyIndex-indexKeyAndPosition-uint256-'></a> `indexKeyAndPosition`\n\n```\nfunction indexKeyAndPosition(uint256 mapKey) returns (uint256 indexKey, uint256 indexPosition)\n```\n\n\n\nReturns the key in the key index which stores the index for the 256-bit\nindex which includes `mapKey` and the position in the index for that key.\n\n\n## <a id='KeyIndex-markSetKey-mapping-uint256----uint256--uint256-'></a> `markSetKey`\n\n```\nfunction markSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey) returns (bool)\n```\n\n\n\nSets a bit at the position in `indexMap` corresponding to `mapKey` if the\nbit is not already set.\n\n\n## Parameters:\n- `keyIndex`: Mapping with indices of set keys in the value map\n\n- `mapKey`: Position in the value map to mark as set\n\n## <a id='KeyIndex-hasKey-mapping-uint256----uint256--uint256-'></a> `hasKey`\n\n```\nfunction hasKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey) returns (bool)\n```\n\n\n\nReturns a boolean indicating whether a value is stored for `mapKey` in the map index.\n\n\n## <a id='KeyIndex-getEncodedSetKeysInRange-mapping-uint256----uint256--uint256-uint256-'></a> `getEncodedSetKeysInRange`\n\n```\nfunction getEncodedSetKeysInRange(mapping(uint256 => uint256) keyIndex, uint256 mapKeyFrom, uint256 mapKeyTo) returns (bytes bitPositions)\n```\n\n\n\nReturns a packed uint16 array with the offsets of all set keys\nbetween `mapKeyFrom` and `mapKeyTo`. Offsets are relative to `mapKeyFrom`\n\n\n## <a id='KeyIndex-findLastSetKey-mapping-uint256----uint256--uint256-uint256-'></a> `findLastSetKey`\n\n```\nfunction findLastSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey, uint256 maxDistance) returns (bool, uint256)\n```\n\n\n\nFind the most recent position before `mapKey` which the index map records\nas having a set value. Returns the key in the value map for that position.\n\n\n## Parameters:\n- `keyIndex`: Mapping with indices of set keys in the value map\n\n- `mapKey`: Position in the value map to look behind\n\n- `maxDistance`: Maximum distance between the found value and `mapKey`\n\n## <a id='KeyIndex-findNextSetKey-mapping-uint256----uint256--uint256-uint256-'></a> `findNextSetKey`\n\n```\nfunction findNextSetKey(mapping(uint256 => uint256) keyIndex, uint256 mapKey, uint256 maxDistance) returns (bool, uint256)\n```\n\n\n\nFind the next position after `mapKey` which the index map records as\nhaving a set value. Returns the key in the value map for that position.\n\n\n## Parameters:\n- `keyIndex`: Mapping with indices of set values in the value map\n\n- `mapKey`: Position in the value map to look ahead\n\n- `maxDistance`: Maximum distance between the found value and `mapKey`\n\n",
  "docs/smart-contracts/oracle/lib/PriceLibrary": "# `PriceLibrary`\n\n\n\n\n\n# Functions:\n- [`pairInitialized(address uniswapFactory, address token, address weth)`](#PriceLibrary-pairInitialized-address-address-address-)\n- [`observePrice(address uniswapFactory, address tokenIn, address quoteToken)`](#PriceLibrary-observePrice-address-address-address-)\n- [`observeTwoWayPrice(address uniswapFactory, address token, address weth)`](#PriceLibrary-observeTwoWayPrice-address-address-address-)\n- [`computeTwoWayAveragePrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2)`](#PriceLibrary-computeTwoWayAveragePrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-)\n- [`computeAveragePrice(uint32 timestampStart, uint224 priceCumulativeStart, uint32 timestampEnd, uint224 priceCumulativeEnd)`](#PriceLibrary-computeAveragePrice-uint32-uint224-uint32-uint224-)\n- [`computeAverageTokenPrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2)`](#PriceLibrary-computeAverageTokenPrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-)\n- [`computeAverageEthPrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2)`](#PriceLibrary-computeAverageEthPrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-)\n- [`computeAverageEthForTokens(struct PriceLibrary.TwoWayAveragePrice prices, uint256 tokenAmount)`](#PriceLibrary-computeAverageEthForTokens-struct-PriceLibrary-TwoWayAveragePrice-uint256-)\n- [`computeAverageTokensForEth(struct PriceLibrary.TwoWayAveragePrice prices, uint256 wethAmount)`](#PriceLibrary-computeAverageTokensForEth-struct-PriceLibrary-TwoWayAveragePrice-uint256-)\n\n## <a id='PriceLibrary-pairInitialized-address-address-address-'></a> `pairInitialized`\n\n```\nfunction pairInitialized(address uniswapFactory, address token, address weth) returns (bool)\n```\n\n\n\n\n\n\n## <a id='PriceLibrary-observePrice-address-address-address-'></a> `observePrice`\n\n```\nfunction observePrice(address uniswapFactory, address tokenIn, address quoteToken) returns (uint32, uint224)\n```\n\n\n\n\n\n\n## <a id='PriceLibrary-observeTwoWayPrice-address-address-address-'></a> `observeTwoWayPrice`\n\n```\nfunction observeTwoWayPrice(address uniswapFactory, address token, address weth) returns (struct PriceLibrary.PriceObservation)\n```\n\n\n\nQuery the current cumulative price of a token in terms of weth\nand the current cumulative price of weth in terms of the token.\n\n\n## <a id='PriceLibrary-computeTwoWayAveragePrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-'></a> `computeTwoWayAveragePrice`\n\n```\nfunction computeTwoWayAveragePrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2) returns (struct PriceLibrary.TwoWayAveragePrice)\n```\n\n\n\nComputes the average price of a token in terms of weth\nand the average price of weth in terms of a token using two\nprice observations.\n\n\n## <a id='PriceLibrary-computeAveragePrice-uint32-uint224-uint32-uint224-'></a> `computeAveragePrice`\n\n```\nfunction computeAveragePrice(uint32 timestampStart, uint224 priceCumulativeStart, uint32 timestampEnd, uint224 priceCumulativeEnd) returns (struct FixedPoint.uq112x112)\n```\n\n\n\n\n\n\n## <a id='PriceLibrary-computeAverageTokenPrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-'></a> `computeAverageTokenPrice`\n\n```\nfunction computeAverageTokenPrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2) returns (struct FixedPoint.uq112x112)\n```\n\n\n\nComputes the average price of the token the price observations\nare for in terms of weth.\n\n\n## <a id='PriceLibrary-computeAverageEthPrice-struct-PriceLibrary-PriceObservation-struct-PriceLibrary-PriceObservation-'></a> `computeAverageEthPrice`\n\n```\nfunction computeAverageEthPrice(struct PriceLibrary.PriceObservation observation1, struct PriceLibrary.PriceObservation observation2) returns (struct FixedPoint.uq112x112)\n```\n\n\n\nComputes the average price of weth in terms of the token\nthe price observations are for.\n\n\n## <a id='PriceLibrary-computeAverageEthForTokens-struct-PriceLibrary-TwoWayAveragePrice-uint256-'></a> `computeAverageEthForTokens`\n\n```\nfunction computeAverageEthForTokens(struct PriceLibrary.TwoWayAveragePrice prices, uint256 tokenAmount) returns (uint144)\n```\n\n\n\nCompute the average value in weth of `tokenAmount` of the\ntoken that the average price values are for.\n\n\n## <a id='PriceLibrary-computeAverageTokensForEth-struct-PriceLibrary-TwoWayAveragePrice-uint256-'></a> `computeAverageTokensForEth`\n\n```\nfunction computeAverageTokensForEth(struct PriceLibrary.TwoWayAveragePrice prices, uint256 wethAmount) returns (uint144)\n```\n\n\n\nCompute the average value of `wethAmount` weth in terms of\nthe token that the average price values are for.\n\n\n",
  "docs/smart-contracts/pool": "# `IndexPool`\n\n# Controls\n\n## `configure` \n\n```\nfunction configure(address controller, string name, string symbol)\n```\n\n\n\nSets the controller address and the token name & symbol.\nNote: This saves on storage costs for multi-step pool deployment.\n\n\n## `initialize` \n\n```\nfunction initialize(address[] tokens, uint256[] balances, uint96[] denorms, address tokenProvider, address unbindHandler)\n```\n\n\n\nSets up the initial assets for the pool.\nNote: `tokenProvider` must have approved the pool to transfer the\ncorresponding `balances` of `tokens`.\n\n\n## `setMaxPoolTokens` \n\n```\nfunction setMaxPoolTokens(uint256 maxPoolTokens)\n```\n\n\n\nSets the maximum number of pool tokens that can be minted.\nThis value will be used in the alpha to limit the maximum damage\nthat can be caused by a catastrophic error. It can be gradually\nincreased as the pool continues to not be exploited.\nIf it is set to 0, the limit will be removed.\n\n## `setSwapFee` \n\n```\nfunction setSwapFee(uint256 swapFee)\n```\n\n\n\nSet the swap fee.\nNote: Swap fee must be between 0.0001% and 10%\n\n\n## `reweighTokens` \n\n```\nfunction reweighTokens(address[] tokens, uint96[] desiredDenorms)\n```\n\n\nSets the desired weights for the pool tokens, which\nwill be adjusted over time as they are swapped.\nNote: This does not check for duplicate tokens or that the total\nof the desired weights is equal to the target total weight (25).\nThose assumptions should be met in the controller. Further, the\nprovided tokens should only include the tokens which are not set\nfor removal.\n\n## `reindexTokens` \n\n```\nfunction reindexTokens(address[] tokens, uint96[] desiredDenorms, uint256[] minimumBalances)\n```\n\n\nUpdate the underlying assets held by the pool and their associated\nweights. Tokens which are not currently bound will be gradually added\nas they are swapped in to reach the provided minimum balances, which must\nbe an amount of tokens worth the minimum weight of the total pool value.\nIf a currently bound token is not received in this call, the token's\ndesired weight will be set to 0.\n\n## `setMinimumBalance` \n\n```\nfunction setMinimumBalance(address token, uint256 minimumBalance)\n```\n\n\n\nUpdates the minimum balance for an uninitialized token.\nThis becomes useful if a token's external price significantly\nrises after being bound, since the pool can not send a token\nout until it reaches the minimum balance.\n\n# Liquidity Provider Actions\n\n## `joinPool` \n\n```\nfunction joinPool(uint256 poolAmountOut, uint256[] maxAmountsIn)\n```\n\n\n\nMint new pool tokens by providing the proportional amount of each\nunderlying token's balance relative to the proportion of pool tokens minted.\nFor any underlying tokens which are not initialized, the caller must provide\nthe proportional share of the minimum balance for the token rather than the\nactual balance.\n\n\n## `joinswapExternAmountIn` \n\n```\nfunction joinswapExternAmountIn(address tokenIn, uint256 tokenAmountIn, uint256 minPoolAmountOut) returns (uint256)\n```\n\n\n\nPay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut`\npool tokens.\nThe pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\nunderlying tokens. Thus a swap fee is charged against the input tokens.\n\n\n## `joinswapPoolAmountOut` \n\n```\nfunction joinswapPoolAmountOut(address tokenIn, uint256 poolAmountOut, uint256 maxAmountIn) returns (uint256)\n```\n\n\n\nPay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`.\nThe pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\nunderlying tokens. Thus a swap fee is charged against the input tokens.\n\n\n## `exitPool` \n\n```\nfunction exitPool(uint256 poolAmountIn, uint256[] minAmountsOut)\n```\n\n\n\nBurns `poolAmountIn` pool tokens in exchange for the amounts of each\nunderlying token's balance proportional to the ratio of tokens burned to\ntotal pool supply. The amount of each token transferred to the caller must\nbe greater than or equal to the associated minimum output amount from the\n`minAmountsOut` array.\n\n# Swaps & Flash Loans\n\n## `exitswapPoolAmountIn` \n\n```\nfunction exitswapPoolAmountIn(address tokenOut, uint256 poolAmountIn, uint256 minAmountOut) returns (uint256)\n```\n\n\n\nBurns `poolAmountIn` pool tokens in exchange for at least `minAmountOut`\nof `tokenOut`. Returns the number of tokens sent to the caller.\nThe pool implicitly burns the tokens for all underlying tokens and swaps them\nto the desired output token. A swap fee is charged against the output tokens.\n\n\n## `exitswapExternAmountOut` \n\n```\nfunction exitswapExternAmountOut(address tokenOut, uint256 tokenAmountOut, uint256 maxPoolAmountIn) returns (uint256)\n```\n\n\n\nBurn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`.\nReturns the number of pool tokens burned.\nThe pool implicitly burns the tokens for all underlying tokens and swaps them\nto the desired output token. A swap fee is charged against the output tokens.\n\n\n## `gulp` \n\n```\nfunction gulp(address token)\n```\n\n\n\nAbsorb any tokens that have been sent to the pool.\nIf the token is not bound, it will be sent to the unbound\ntoken handler.\n\n## `flashBorrow` \n\n```\nfunction flashBorrow(address recipient, address token, uint256 amount, bytes data)\n```\n\n\n\nExecute a flash loan, transferring `amount` of `token` to `recipient`.\n`amount` must be repaid with `swapFee` interest by the end of the transaction.\n\n\n## `swapExactAmountIn` \n\n```\nfunction swapExactAmountIn(address tokenIn, uint256 tokenAmountIn, address tokenOut, uint256 minAmountOut, uint256 maxPrice) returns (uint256, uint256)\n```\n\n\n\nExecute a token swap with a specified amount of input\ntokens and a minimum amount of output tokens.\nNote: Will revert if `tokenOut` is uninitialized.\n\n\n## `swapExactAmountOut` \n\n```\nfunction swapExactAmountOut(address tokenIn, uint256 maxAmountIn, address tokenOut, uint256 tokenAmountOut, uint256 maxPrice) returns (uint256, uint256)\n```\n\n\n\nTrades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut`\nof `tokenOut`.\nReturns the actual input amount and the new spot price after the swap,\nwhich can not exceed `maxPrice`.\n\n# Queries\n\n## `isPublicSwap` \n\n```\nfunction isPublicSwap() returns (bool)\n```\n\n\nCheck if swapping tokens and joining the pool is allowed.\n\n## `getSwapFee` \n\n```\nfunction getSwapFee() returns (uint256)\n```\n\n\n## `getController` \n\n```\nfunction getController() returns (address)\n```\n\n\nReturns the controller address.\n\n## `getMaxPoolTokens` \n\n```\nfunction getMaxPoolTokens() returns (uint256)\n```\n\nReturns the maximum supply. If zero, there is no maximum.\n\n## `isBound` \n\n```\nfunction isBound(address t) returns (bool)\n```\n\n\nCheck if a token is bound to the pool.\n\n## `getNumTokens` \n\n```\nfunction getNumTokens() returns (uint256)\n```\n\n\nGet the number of tokens bound to the pool.\n\n## `getCurrentTokens` \n\n```\nfunction getCurrentTokens() returns (address[] tokens)\n```\n\n\nGet all bound tokens.\n\n## `getCurrentDesiredTokens` \n\n```\nfunction getCurrentDesiredTokens() returns (address[] tokens)\n```\n\n\nReturns the list of tokens which have a desired weight above 0.\nTokens with a desired weight of 0 are set to be phased out of the pool.\n\n## `getDenormalizedWeight` \n\n```\nfunction getDenormalizedWeight(address token) returns (uint256)\n```\n\n\nReturns the denormalized weight of a bound token.\n\n## `getTokenRecord` \n\n```\nfunction getTokenRecord(address token) returns (struct IIndexPool.Record record)\n```\n\n\nReturns the record for a token bound to the pool.\n\n## `extrapolatePoolValueFromToken` \n\n```\nfunction extrapolatePoolValueFromToken() returns (address, uint256)\n```\n\n\nFinds the first token which is both initialized and has a\ndesired weight above 0, then returns the address of that token\nand the extrapolated value of the pool in terms of that token.\nThe value is extrapolated by multiplying the token's\nbalance by the reciprocal of its normalized weight.\n\n\n## `getTotalDenormalizedWeight` \n\n```\nfunction getTotalDenormalizedWeight() returns (uint256)\n```\n\n\nGet the total denormalized weight of the pool.\n\n## `getBalance` \n\n```\nfunction getBalance(address token) returns (uint256)\n```\n\n\nReturns the stored balance of a bound token.\n\n## `getMinimumBalance` \n\n```\nfunction getMinimumBalance(address token) returns (uint256)\n```\n\n\n\nGet the minimum balance of an uninitialized token.\nNote: Throws if the token is initialized.\n\n## `getUsedBalance` \n\n```\nfunction getUsedBalance(address token) returns (uint256)\n```\n\n\n\nReturns the balance of a token which is used in price\ncalculations. If the token is initialized, this is the\nstored balance; if not, this is the minimum balance.\n\n## `getSpotPrice` \n\n```\nfunction getSpotPrice(address tokenIn, address tokenOut) returns (uint256)\n```\n\n\n\nReturns the spot price for `tokenOut` in terms of `tokenIn`.\n\n# Internal Functions\n\n## `_pullPoolShare` \n\n```\nfunction _pullPoolShare(address from, uint256 amount)\n```\n\n\n\n\n\n## `_pushPoolShare` \n\n```\nfunction _pushPoolShare(address to, uint256 amount)\n```\n\n\n\n\n\n## `_mintPoolShare` \n\n```\nfunction _mintPoolShare(uint256 amount)\n```\n\n\n\n\n\n## `_burnPoolShare` \n\n```\nfunction _burnPoolShare(uint256 amount)\n```\n\n\n\n\n\n## `_pullUnderlying` \n\n```\nfunction _pullUnderlying(address erc20, address from, uint256 amount)\n```\n\n\n\n\n\n## `_pushUnderlying` \n\n```\nfunction _pushUnderlying(address erc20, address to, uint256 amount)\n```\n\n\n\n\n\n## `_bind` \n\n```\nfunction _bind(address token, uint256 minimumBalance, uint96 desiredDenorm)\n```\n\n\n\nBind a token by address without actually depositing a balance.\nThe token will be unable to be swapped out until it reaches the minimum balance.\nNote: Token must not already be bound.\nNote: `minimumBalance` should represent an amount of the token which is worth\nthe portion of the current pool value represented by the minimum weight.\n\n\n## `_unbind` \n\n```\nfunction _unbind(address token)\n```\n\n\n\nRemove a token from the pool.\nReplaces the address in the tokens array with the last address,\nthen removes it from the array.\nNote: This should only be called after the total weight has been adjusted.\nNote: Must be called in a function with:\n- _lock_ modifier to prevent reentrance\n- requirement that the token is bound\n\n## `_setDesiredDenorm` \n\n```\nfunction _setDesiredDenorm(address token, uint96 desiredDenorm)\n```\n\n\n## `_increaseDenorm` \n\n```\nfunction _increaseDenorm(struct IIndexPool.Record record, address token)\n```\n\n\n## `_decreaseDenorm` \n\n```\nfunction _decreaseDenorm(struct IIndexPool.Record record, address token)\n```\n\n\n## `_updateInputToken` \n\n```\nfunction _updateInputToken(address token, struct IIndexPool.Record record, uint256 realBalance)\n```\n\n\n\nHandles weight changes and initialization of an\ninput token.\nIf the token is not initialized and the new balance is\nstill below the minimum, this will not do anything.\nIf the token is not initialized but the new balance will\nbring the token above the minimum balance, this will\nmark the token as initialized, remove the minimum\nbalance and set the weight to the minimum weight plus\n1%.\n\n\n## `_getInputToken` \n\n```\nfunction _getInputToken(address token) returns (struct IIndexPool.Record record, uint256 realBalance)\n```\n\n\n\nGet the record for a token which is being swapped in.\nThe token must be bound to the pool. If the token is not\ninitialized (meaning it does not have the minimum balance)\nthis function will return the actual balance of the token\nwhich the pool holds, but set the record's balance and weight\nto the token's minimum balance and the pool's minimum weight.\nThis allows the token swap to be priced correctly even if the\npool does not own any of the tokens.\n\n## `_getOutputToken` \n\n```\nfunction _getOutputToken(address token) returns (struct IIndexPool.Record record)\n```\n\n\n\n\n\n",
  "docs/smart-contracts/proxies/DelegateCallProxyManager": "## `DelegateCallProxyManager`\n\n\n\nContract that manages deployment and upgrades of delegatecall proxies.\nAn implementation identifier can be created on the proxy manager which is\nused to specify the logic address for a particular contract type, and to\nupgrade the implementation as needed.\n\n## **Proxy Types**\nA [one-to-one proxy](./DelegateCallProxyOneToOne.md) is a single proxy contract with an upgradeable implementation\naddress.\n\nA [many-to-one proxy](./DelegateCallProxyManyToOne.md) is a single upgradeable implementation address that may be\nused by many proxy contracts.\n\n## **Access Control**\nThe proxy manager has a single address as its owner.\nThe owner is the sole account with the following permissions:\n- Create new many-to-one implementations\n- Create new one-to-one proxies\n- Modify the implementation address of existing proxies\n- Lock proxies\n- Designate approved deployers\n- Remove approved deployers\n- Modify the owner address\n\nApproved deployers may only deploy many-to-one proxies.\n## **Upgrades**\nProxies can be upgraded by the owner if they are not locked.\nMany-to-one proxy implementations are upgraded by calling the holder contract\nfor the implementation ID being upgraded.\nOne-to-one proxies are upgraded by calling the proxy contract directly.\nThe owner can lock a one-to-one proxy or many-to-one implementation ID so that\nit becomes impossible to upgrade.\n\n# Functions:\n- [Access Controls](#access-controls)\n  - [`approveDeployer(address deployer)`](#DelegateCallProxyManager-approveDeployer-address-)\n  - [`revokeDeployerApproval(address deployer)`](#DelegateCallProxyManager-revokeDeployerApproval-address-)\n- [Implementation Management](#implementation-management)\n  - [`createManyToOneProxyRelationship(bytes32 implementationID, address implementation)`](#DelegateCallProxyManager-createManyToOneProxyRelationship-bytes32-address-)\n  - [`lockImplementationManyToOne(bytes32 implementationID)`](#DelegateCallProxyManager-lockImplementationManyToOne-bytes32-)\n  - [`lockImplementationOneToOne(address proxyAddress)`](#DelegateCallProxyManager-lockImplementationOneToOne-address-)\n  - [`setImplementationAddressManyToOne(bytes32 implementationID, address implementation)`](#DelegateCallProxyManager-setImplementationAddressManyToOne-bytes32-address-)\n  - [`setImplementationAddressOneToOne(address proxyAddress, address implementation)`](#DelegateCallProxyManager-setImplementationAddressOneToOne-address-address-)\n- [Proxy Deployment](#proxy-deployment)\n  - [`deployProxyOneToOne(bytes32 suppliedSalt, address implementation)`](#DelegateCallProxyManager-deployProxyOneToOne-bytes32-address-)\n  - [`deployProxyManyToOne(bytes32 implementationID, bytes32 suppliedSalt)`](#DelegateCallProxyManager-deployProxyManyToOne-bytes32-bytes32-)\n- [Queries](#queries)\n  - [`isImplementationLocked(bytes32 implementationID)`](#DelegateCallProxyManager-isImplementationLocked-bytes32-)\n  - [`isImplementationLocked(address proxyAddress)`](#DelegateCallProxyManager-isImplementationLocked-address-)\n  - [`isApprovedDeployer(address deployer)`](#DelegateCallProxyManager-isApprovedDeployer-address-)\n  - [`getImplementationHolder()`](#DelegateCallProxyManager-getImplementationHolder--)\n  - [`getImplementationHolder(bytes32 implementationID)`](#DelegateCallProxyManager-getImplementationHolder-bytes32-)\n  - [`computeProxyAddressOneToOne(address originator, bytes32 suppliedSalt)`](#DelegateCallProxyManager-computeProxyAddressOneToOne-address-bytes32-)\n  - [`computeProxyAddressManyToOne(address originator, bytes32 implementationID, bytes32 suppliedSalt)`](#DelegateCallProxyManager-computeProxyAddressManyToOne-address-bytes32-bytes32-)\n  - [`computeHolderAddressManyToOne(bytes32 implementationID)`](#DelegateCallProxyManager-computeHolderAddressManyToOne-bytes32-)\n- [Internal Functions](#internal-functions)\n  - [`_setImplementation(address proxyOrHolder, address implementation)`](#DelegateCallProxyManager-_setImplementation-address-address-)\n\n# Access Controls\n\n## <a id='DelegateCallProxyManager-approveDeployer-address-'></a> `approveDeployer`\n\n```\nfunction approveDeployer(address deployer)\n```\n\n\n\nAllows `deployer` to deploy many-to-one proxies.\n\n\n## <a id='DelegateCallProxyManager-revokeDeployerApproval-address-'></a> `revokeDeployerApproval`\n\n```\nfunction revokeDeployerApproval(address deployer)\n```\n\n\n\nPrevents `deployer` from deploying many-to-one proxies.\n\n# Implementation Management\n\n## <a id='DelegateCallProxyManager-createManyToOneProxyRelationship-bytes32-address-'></a> `createManyToOneProxyRelationship`\n\n```\nfunction createManyToOneProxyRelationship(bytes32 implementationID, address implementation)\n```\n\n\n\nCreates a many-to-one proxy relationship.\nDeploys an implementation holder contract which stores the\nimplementation address for many proxies. The implementation\naddress can be updated on the holder to change the runtime\ncode used by all its proxies.\n\n\n## Parameters:\n- `implementationID`: ID for the implementation, used to identify the\nproxies that use it. Also used as the salt in the create2 call when\ndeploying the implementation holder contract.\n\n- `implementation`: Address with the runtime code the proxies\nshould use.\n\n## <a id='DelegateCallProxyManager-lockImplementationManyToOne-bytes32-'></a> `lockImplementationManyToOne`\n\n```\nfunction lockImplementationManyToOne(bytes32 implementationID)\n```\n\n\n\nLock the current implementation for `proxyAddress` so that it can never be upgraded again.\n\n\n## <a id='DelegateCallProxyManager-lockImplementationOneToOne-address-'></a> `lockImplementationOneToOne`\n\n```\nfunction lockImplementationOneToOne(address proxyAddress)\n```\n\n\n\nLock the current implementation for `proxyAddress` so that it can never be upgraded again.\n\n\n## <a id='DelegateCallProxyManager-setImplementationAddressManyToOne-bytes32-address-'></a> `setImplementationAddressManyToOne`\n\n```\nfunction setImplementationAddressManyToOne(bytes32 implementationID, address implementation)\n```\n\n\n\nUpdates the implementation address for a many-to-one\nproxy relationship.\n\n\n## Parameters:\n- `implementationID`: Identifier for the implementation.\n\n- `implementation`: Address with the runtime code the proxies\nshould use.\n\n## <a id='DelegateCallProxyManager-setImplementationAddressOneToOne-address-address-'></a> `setImplementationAddressOneToOne`\n\n```\nfunction setImplementationAddressOneToOne(address proxyAddress, address implementation)\n```\n\n\n\nUpdates the implementation address for a one-to-one proxy.\nNote: This could work for many-to-one as well if the caller\nprovides the implementation holder address in place of the\nproxy address, as they use the same access control and update\nmechanism.\n\n\n## Parameters:\n- `proxyAddress`: Address of the deployed proxy\n\n- `implementation`: Address with the runtime code for\nthe proxy to use.\n\n# Proxy Deployment\n\n## <a id='DelegateCallProxyManager-deployProxyOneToOne-bytes32-address-'></a> `deployProxyOneToOne`\n\n```\nfunction deployProxyOneToOne(bytes32 suppliedSalt, address implementation) returns (address proxyAddress)\n```\n\n\n\nDeploy a proxy contract with a one-to-one relationship\nwith its implementation.\nThe proxy will have its own implementation address which can\nbe updated by the proxy manager.\n\n\n## Parameters:\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n- `implementation`: Address of the contract with the runtime\ncode that the proxy should use.\n\n## <a id='DelegateCallProxyManager-deployProxyManyToOne-bytes32-bytes32-'></a> `deployProxyManyToOne`\n\n```\nfunction deployProxyManyToOne(bytes32 implementationID, bytes32 suppliedSalt) returns (address proxyAddress)\n```\n\n\n\nDeploy a proxy with a many-to-one relationship with its implemenation.\nThe proxy will call the implementation holder for every transaction to\ndetermine the address to use in calls.\n\n\n## Parameters:\n- `implementationID`: Identifier for the proxy's implementation.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n# Queries\n\n## <a id='DelegateCallProxyManager-isImplementationLocked-bytes32-'></a> `isImplementationLocked`\n\n```\nfunction isImplementationLocked(bytes32 implementationID) returns (bool)\n```\n\n\n\nReturns a boolean stating whether `implementationID` is locked.\n\n\n## <a id='DelegateCallProxyManager-isImplementationLocked-address-'></a> `isImplementationLocked`\n\n```\nfunction isImplementationLocked(address proxyAddress) returns (bool)\n```\n\n\n\nReturns a boolean stating whether `proxyAddress` is locked.\n\n\n## <a id='DelegateCallProxyManager-isApprovedDeployer-address-'></a> `isApprovedDeployer`\n\n```\nfunction isApprovedDeployer(address deployer) returns (bool)\n```\n\n\n\nReturns a boolean stating whether `deployer` is allowed to deploy many-to-one\nproxies.\n\n\n## <a id='DelegateCallProxyManager-getImplementationHolder--'></a> `getImplementationHolder`\n\n```\nfunction getImplementationHolder() returns (address)\n```\n\n\n\nQueries the temporary storage value `_implementationHolder`.\nThis is used in the constructor of the many-to-one proxy contract\nso that the create2 address is static (adding constructor arguments\nwould change the codehash) and the implementation holder can be\nstored as a constant.\n\n\n## <a id='DelegateCallProxyManager-getImplementationHolder-bytes32-'></a> `getImplementationHolder`\n\n```\nfunction getImplementationHolder(bytes32 implementationID) returns (address)\n```\n\n\n\nReturns the address of the implementation holder contract\nfor `implementationID`.\n\n\n## <a id='DelegateCallProxyManager-computeProxyAddressOneToOne-address-bytes32-'></a> `computeProxyAddressOneToOne`\n\n```\nfunction computeProxyAddressOneToOne(address originator, bytes32 suppliedSalt) returns (address)\n```\n\n\n\nComputes the create2 address for a one-to-one proxy requested\nby `originator` using `suppliedSalt`.\n\n\n## Parameters:\n- `originator`: Address of the account requesting deployment.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='DelegateCallProxyManager-computeProxyAddressManyToOne-address-bytes32-bytes32-'></a> `computeProxyAddressManyToOne`\n\n```\nfunction computeProxyAddressManyToOne(address originator, bytes32 implementationID, bytes32 suppliedSalt) returns (address)\n```\n\n\n\nComputes the create2 address for a many-to-one proxy for the\nimplementation `implementationID` requested by `originator` using\n`suppliedSalt`.\n\n\n## Parameters:\n- `originator`: Address of the account requesting deployment.\n\n- `implementationID`: The identifier for the contract implementation.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='DelegateCallProxyManager-computeHolderAddressManyToOne-bytes32-'></a> `computeHolderAddressManyToOne`\n\n```\nfunction computeHolderAddressManyToOne(bytes32 implementationID) returns (address)\n```\n\n\n\nComputes the create2 address of the implementation holder\nfor `implementationID`.\n\n\n## Parameters:\n- `implementationID`: The identifier for the contract implementation.\n\n# Internal Functions\n\n## <a id='DelegateCallProxyManager-_setImplementation-address-address-'></a> `_setImplementation`\n\n```\nfunction _setImplementation(address proxyOrHolder, address implementation)\n```\n\n\n\nSets the implementation address for a one-to-one proxy or\nmany-to-one implementation holder. Both use the same access\ncontrol and update mechanism, which is the receipt of a call\nfrom the proxy manager with the abi-encoded implementation address\nas the only calldata.\nNote: Verifies that the implementation address is a contract.\n\n\n## Parameters:\n- `proxyOrHolder`: Address of the one-to-one proxy or\nmany-to-one implementation holder contract.\n\n- `implementation`: Address of the contract with the runtime\ncode that the proxy or proxies should use.\n\n",
  "docs/smart-contracts/proxies/DelegateCallProxyManyToOne": "## `DelegateCallProxyManyToOne`\n\nProxy contract which uses an implementation address shared with many\nother proxies.\nAn implementation holder contract stores the upgradeable implementation address.\nWhen the proxy is called, it queries the implementation address from the holder\ncontract and delegatecalls the returned address, forwarding the received calldata\nand ether.\nNote: This contract does not verify that the implementation\naddress is a valid delegation target. The manager must perform\nthis safety check before updating the implementation on the holder.\n\n# Functions:\n- [`_implementation()`](#DelegateCallProxyManyToOne-_implementation--)\n\n## <a id='DelegateCallProxyManyToOne-_implementation--'></a> `_implementation`\n\n```\nfunction _implementation() returns (address)\n```\n\n\n\nQueries the implementation address from the implementation holder.\n\n\n",
  "docs/smart-contracts/proxies/DelegateCallProxyOneToOne": "# `DelegateCallProxyOneToOne`\n\nUpgradeable delegatecall proxy for a single contract.\n\nThis proxy stores an implementation address which can be upgraded by the proxy manager.\n\nTo upgrade the implementation, the manager calls the proxy with the abi encoded implementation address.\n\nIf any other account calls the proxy, it will delegatecall the implementation address with the received calldata and ether.\n\nIf the call succeeds, it will return with the received returndata.\nIf it reverts, it will revert with the received revert data.\n\n## Notes\n\nThe storage slot for the implementation address is: `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`. This slot must not be used by the implementation contract.\n\nThis contract does not verify that the implementation address is a valid delegation target. The manager must perform this safety check.\n\n# Functions\n  - [<a id='DelegateCallProxyOneToOne-_implementation--'></a> `_implementation`](#-_implementation)\n  - [<a id='DelegateCallProxyOneToOne-_beforeFallback--'></a> `_beforeFallback`](#-_beforefallback)\n\n## <a id='DelegateCallProxyOneToOne-_implementation--'></a> `_implementation`\n\n```\nfunction _implementation() returns (address)\n```\n\n\n\nReads the implementation address from storage.\n\n\n## <a id='DelegateCallProxyOneToOne-_beforeFallback--'></a> `_beforeFallback`\n\n```\nfunction _beforeFallback()\n```\n\n\n\nHook that is called before falling back to the implementation.\nChecks if the call is from the owner.\nIf it is, reads the abi-encoded implementation address from calldata and stores\nit at the slot `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`,\nthen returns with no data.\nIf it is not, continues execution with the fallback function.\n\n\n",
  "docs/smart-contracts/proxies/ManyToOneImplementationHolder": "## `ManyToOneImplementationHolder`\n\n\n\nThe ManyToOneImplementationHolder stores an upgradeable implementation address\nin storage, which many-to-one proxies query at execution time to determine which\ncontract to delegate to.\nThe manager can upgrade the implementation address by calling the holder with the\nabi-encoded address as calldata. If any other account calls the implementation holder,\nit will return the implementation address.\nThis pattern was inspired by the DharmaUpgradeBeacon from 0age\nhttps://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/upgradeability/smart-wallet/DharmaUpgradeBeacon.sol\n\n# Functions:\n- [`fallback()`](#ManyToOneImplementationHolder-fallback--)\n\n## <a id='ManyToOneImplementationHolder-fallback--'></a> `fallback`\n\n```\nfunction fallback()\n```\n\n\n\nFallback function for the contract.\nUsed by proxies to read the implementation address and used\nby the proxy manager to set the implementation address.\nIf called by the owner, reads the implementation address from\ncalldata (must be abi-encoded) and stores it to the first slot.\nOtherwise, returns the stored implementation address.\n\n\n",
  "docs/smart-contracts/proxies/SaltyLib": "## `SaltyLib`\n\n\n\nLibrary for computing create2 salts and addresses for proxies\ndeployed by `DelegateCallProxyManager`.\nBecause the proxy factory is meant to be used by multiple contracts,\nwe use a salt derivation pattern that includes the address of the\ncontract that requested the proxy deployment, a salt provided by that\ncontract and the implementation ID used (for many-to-one proxies only).\n\n# Functions:\n- [`deriveManyToOneSalt(address originator, bytes32 implementationID, bytes32 suppliedSalt)`](#SaltyLib-deriveManyToOneSalt-address-bytes32-bytes32-)\n- [`deriveOneToOneSalt(address originator, bytes32 suppliedSalt)`](#SaltyLib-deriveOneToOneSalt-address-bytes32-)\n- [`computeProxyAddressOneToOne(address deployer, address originator, bytes32 suppliedSalt)`](#SaltyLib-computeProxyAddressOneToOne-address-address-bytes32-)\n- [`computeProxyAddressManyToOne(address deployer, address originator, bytes32 implementationID, bytes32 suppliedSalt)`](#SaltyLib-computeProxyAddressManyToOne-address-address-bytes32-bytes32-)\n- [`computeHolderAddressManyToOne(address deployer, bytes32 implementationID)`](#SaltyLib-computeHolderAddressManyToOne-address-bytes32-)\n\n## <a id='SaltyLib-deriveManyToOneSalt-address-bytes32-bytes32-'></a> `deriveManyToOneSalt`\n\n```\nfunction deriveManyToOneSalt(address originator, bytes32 implementationID, bytes32 suppliedSalt) returns (bytes32)\n```\n\n\n\nDerives the create2 salt for a many-to-one proxy.\nMany different contracts in the Indexed framework may use the\nsame implementation contract, and they all use the same init\ncode, so we derive the actual create2 salt from a combination\nof the implementation ID, the address of the account requesting\ndeployment and the user-supplied salt.\n\n\n## Parameters:\n- `originator`: Address of the account requesting deployment.\n\n- `implementationID`: The identifier for the contract implementation.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='SaltyLib-deriveOneToOneSalt-address-bytes32-'></a> `deriveOneToOneSalt`\n\n```\nfunction deriveOneToOneSalt(address originator, bytes32 suppliedSalt) returns (bytes32)\n```\n\n\n\nDerives the create2 salt for a one-to-one proxy.\n\n\n## Parameters:\n- `originator`: Address of the account requesting deployment.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='SaltyLib-computeProxyAddressOneToOne-address-address-bytes32-'></a> `computeProxyAddressOneToOne`\n\n```\nfunction computeProxyAddressOneToOne(address deployer, address originator, bytes32 suppliedSalt) returns (address)\n```\n\n\n\nComputes the create2 address for a one-to-one proxy deployed\nby `deployer` (the factory) when requested by `originator` using\n`suppliedSalt`.\n\n\n## Parameters:\n- `deployer`: Address of the proxy factory.\n\n- `originator`: Address of the account requesting deployment.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='SaltyLib-computeProxyAddressManyToOne-address-address-bytes32-bytes32-'></a> `computeProxyAddressManyToOne`\n\n```\nfunction computeProxyAddressManyToOne(address deployer, address originator, bytes32 implementationID, bytes32 suppliedSalt) returns (address)\n```\n\n\n\nComputes the create2 address for a many-to-one proxy for the\nimplementation `implementationID` deployed by `deployer` (the factory)\nwhen requested by `originator` using `suppliedSalt`.\n\n\n## Parameters:\n- `deployer`: Address of the proxy factory.\n\n- `originator`: Address of the account requesting deployment.\n\n- `implementationID`: The identifier for the contract implementation.\n\n- `suppliedSalt`: Salt provided by the account requesting deployment.\n\n## <a id='SaltyLib-computeHolderAddressManyToOne-address-bytes32-'></a> `computeHolderAddressManyToOne`\n\n```\nfunction computeHolderAddressManyToOne(address deployer, bytes32 implementationID) returns (address)\n```\n\n\n\nComputes the create2 address of the implementation holder\nfor `implementationID`.\n\n\n## Parameters:\n- `deployer`: Address of the proxy factory.\n\n- `implementationID`: The identifier for the contract implementation.\n\n",
  "docs/smart-contracts/proxies/proxies": "# [@indexed-finance/proxies](https://github.com/indexed-finance/proxies)\n\n[Github](https://github.com/indexed-finance/proxies)\n\n[NPM](https://www.npmjs.com/package/@indexed-finance/proxies)\n\nIndexed uses proxies to instantiate many clones of specific contract templates. Index pools and their initialization contracts are deployed as proxies, which greatly reduces gas costs and allows any discovered bugs to be patched without any migration procedure.\n\nA Proxy Manager contract controls the deployment and upgrading of proxies and their implementations. The proxy manager is controlled by the governance contract, which can add new contract templates that proxies can use, deploy singleton proxies, modify the implementation addresses of existing proxies, and approve specific addresses to deploy copies of an existing template.\n\nThe manager can deploy two types of proxies: many-to-one and one-to-one.\n\nA one-to-one proxy is a single proxy contract which stores its own implementation address. When the proxy is called, it reads the implementation address from storage and delegates the transaction to it.\n\nA many-to-one proxy is a proxy contract which shares an implementation address with many other proxies. Implementations for many-to-one proxies are identified by a 32 byte ID which is mapped to an implementation holder contract. The implementation holder's address is stored in the proxy contracts' bytecode as a constant value. When the proxy is called, it queries the implementation address from the implementation holder, then delegates the transaction to it.",
  "docs/smart-contracts/token-seller": "# `UnboundTokenSeller`\n\nContract for swapping undesired tokens to desired tokens for an index pool.\n\nThis contract is deployed as a proxy for each index pool. When tokens are unbound from a pool, they are transferred to this contract and sold on UniSwap or to anyone who calls the contract in exchange for any token which is currently bound to its index pool and which has a desired weight about zero.\n\nIt uses a short-term uniswap price oracle to price swaps and has a configurable slippage rate which determines the range around the moving average for which it will accept a trade.\n\n\n## `constructor` \n\n```\nfunction constructor(contract IUniswapV2Router02 uniswapRouter, contract UniSwapV2PriceOracle oracle, address controller)\n```\n\n# Controls\n\n## `initialize` \n\n```\nfunction initialize(contract IPool pool, uint8 premiumPercent)\n```\n\n\n\nInitialize the proxy contract with the acceptable premium rate and the address of the pool it is for.\n\n## `setPremiumRate` \n\n```\nfunction setPremiumRate(uint8 premiumPercent)\n```\n\n\n\nSet the premium rate as a percent.\n\n## `emergencyExecuteSwapTokensForExactTokens` \n\n```\nfunction emergencyExecuteSwapTokensForExactTokens(address tokenIn, address tokenOut, uint256 maxAmountIn, uint256 amountOut, address[] path)\n```\n\n\n\nEmergency function that allows the controller to force a token\nsale through UniSwap. This exists in case of an emergency which\ndemands immediate removal of a token.\n\n# Pool Interaction\n\n## `handleUnbindToken` \n\n```\nfunction handleUnbindToken(address token, uint256 amount)\n```\n\nReceive `amount` of `token` from the pool.\n\n# UniSwap Trades\n\n## `executeSwapTokensForExactTokens` \n\n```\nfunction executeSwapTokensForExactTokens(address tokenIn, address tokenOut, uint256 maxAmountIn, uint256 amountOut, address[] path) returns (uint256 premiumPaidToCaller)\n```\n\n\n\nExecute a trade with UniSwap to sell some tokens held by the contract\nfor some tokens desired by the pool and pays the caller any tokens received\nabove the minimum acceptable output.\n\n\n## `executeSwapExactTokensForTokens` \n\n```\nfunction executeSwapExactTokensForTokens(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut, address[] path) returns (uint256 premiumPaidToCaller)\n```\n\n\n\nExecutes a trade with UniSwap to sell some tokens held by the contract\nfor some tokens desired by the pool and pays the caller any tokens received\nabove the minimum acceptable output.\n\n# Caller Trades\n\n## `swapExactTokensForTokens` \n\n```\nfunction swapExactTokensForTokens(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut) returns (uint256 amountOut)\n```\n\n\n\nSwap exactly `amountIn` of `tokenIn` for at least `minAmountOut`\nof `tokenOut`.\n\n\n## `swapTokensForExactTokens` \n\n```\nfunction swapTokensForExactTokens(address tokenIn, address tokenOut, uint256 maxAmountIn, uint256 amountOut) returns (uint256 amountIn)\n```\n\n\n\nSwap up to `maxAmountIn` of `tokenIn` for exactly `amountOut`\nof `tokenOut`.\n\n# Price Queries\n\n## `calcInGivenOut` \n\n```\nfunction calcInGivenOut(\n  address tokenIn,\n  address tokenOut,\n  uint256 amountOut\n) returns (uint256 amountIn)\n```\n\nCalculate the amount of `tokenIn` the pool will accept for\n`amountOut` of `tokenOut`.\n\n## `calcOutGivenIn` \n\n```\nfunction calcOutGivenIn(\n  address tokenIn,\n  address tokenOut,\n  uint256 amountIn\n) returns (uint256 amountOut)\n```\n\n\nCalculate the amount of `tokenOut` the pool will give for\n`amountIn` of `tokenIn`.",
  "faq": "# Foo?\n\n## Bar.\n\n# Foo?\n\n## Bar.\n\n# Foo?\n\n## Bar?\n"
}